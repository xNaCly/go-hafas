// Package vbbraw provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version 2.4.1 DO NOT EDIT.
package vbbraw

import (
	"context"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	AccessIdScopes = "accessId.Scopes"
)

// Defines values for ArrivalJourneyStatus.
const (
	ArrivalJourneyStatusA ArrivalJourneyStatus = "A"
	ArrivalJourneyStatusP ArrivalJourneyStatus = "P"
	ArrivalJourneyStatusR ArrivalJourneyStatus = "R"
	ArrivalJourneyStatusS ArrivalJourneyStatus = "S"
)

// Defines values for ArrivalPrognosisType.
const (
	ArrivalPrognosisTypeCALCULATED ArrivalPrognosisType = "CALCULATED"
	ArrivalPrognosisTypeCORRECTED  ArrivalPrognosisType = "CORRECTED"
	ArrivalPrognosisTypeMANUAL     ArrivalPrognosisType = "MANUAL"
	ArrivalPrognosisTypePROGNOSED  ArrivalPrognosisType = "PROGNOSED"
	ArrivalPrognosisTypeREPORTED   ArrivalPrognosisType = "REPORTED"
)

// Defines values for ArrivalRtCnclDataSourceType.
const (
	ArrivalRtCnclDataSourceTypeARAMIS    ArrivalRtCnclDataSourceType = "ARAMIS"
	ArrivalRtCnclDataSourceTypeBLACKLIST ArrivalRtCnclDataSourceType = "BLACKLIST"
	ArrivalRtCnclDataSourceTypeDDS       ArrivalRtCnclDataSourceType = "DDS"
	ArrivalRtCnclDataSourceTypeDEFAULT   ArrivalRtCnclDataSourceType = "DEFAULT"
	ArrivalRtCnclDataSourceTypeFE        ArrivalRtCnclDataSourceType = "FE"
	ArrivalRtCnclDataSourceTypeFIS       ArrivalRtCnclDataSourceType = "FIS"
	ArrivalRtCnclDataSourceTypeGTFS      ArrivalRtCnclDataSourceType = "GTFS"
	ArrivalRtCnclDataSourceTypeHIM       ArrivalRtCnclDataSourceType = "HIM"
	ArrivalRtCnclDataSourceTypeHRC       ArrivalRtCnclDataSourceType = "HRC"
	ArrivalRtCnclDataSourceTypeHRX       ArrivalRtCnclDataSourceType = "HRX"
	ArrivalRtCnclDataSourceTypePAISA     ArrivalRtCnclDataSourceType = "PAISA"
	ArrivalRtCnclDataSourceTypeRTABO2    ArrivalRtCnclDataSourceType = "RTABO_2"
	ArrivalRtCnclDataSourceTypeSIRI      ArrivalRtCnclDataSourceType = "SIRI"
	ArrivalRtCnclDataSourceTypeUIC       ArrivalRtCnclDataSourceType = "UIC"
	ArrivalRtCnclDataSourceTypeVDV       ArrivalRtCnclDataSourceType = "VDV"
)

// Defines values for ConnectionReliabilityTypeAlternative.
const (
	ConnectionReliabilityTypeAlternativeABORTIVE   ConnectionReliabilityTypeAlternative = "ABORTIVE"
	ConnectionReliabilityTypeAlternativeGUARANTEED ConnectionReliabilityTypeAlternative = "GUARANTEED"
	ConnectionReliabilityTypeAlternativeHIGH       ConnectionReliabilityTypeAlternative = "HIGH"
	ConnectionReliabilityTypeAlternativeLOW        ConnectionReliabilityTypeAlternative = "LOW"
	ConnectionReliabilityTypeAlternativeUNDEF      ConnectionReliabilityTypeAlternative = "UNDEF"
)

// Defines values for ConnectionReliabilityTypeOriginal.
const (
	ConnectionReliabilityTypeOriginalABORTIVE   ConnectionReliabilityTypeOriginal = "ABORTIVE"
	ConnectionReliabilityTypeOriginalGUARANTEED ConnectionReliabilityTypeOriginal = "GUARANTEED"
	ConnectionReliabilityTypeOriginalHIGH       ConnectionReliabilityTypeOriginal = "HIGH"
	ConnectionReliabilityTypeOriginalLOW        ConnectionReliabilityTypeOriginal = "LOW"
	ConnectionReliabilityTypeOriginalUNDEF      ConnectionReliabilityTypeOriginal = "UNDEF"
)

// Defines values for DepartureJourneyStatus.
const (
	DepartureJourneyStatusA DepartureJourneyStatus = "A"
	DepartureJourneyStatusP DepartureJourneyStatus = "P"
	DepartureJourneyStatusR DepartureJourneyStatus = "R"
	DepartureJourneyStatusS DepartureJourneyStatus = "S"
)

// Defines values for DeparturePrognosisType.
const (
	DeparturePrognosisTypeCALCULATED DeparturePrognosisType = "CALCULATED"
	DeparturePrognosisTypeCORRECTED  DeparturePrognosisType = "CORRECTED"
	DeparturePrognosisTypeMANUAL     DeparturePrognosisType = "MANUAL"
	DeparturePrognosisTypePROGNOSED  DeparturePrognosisType = "PROGNOSED"
	DeparturePrognosisTypeREPORTED   DeparturePrognosisType = "REPORTED"
)

// Defines values for DepartureRtCnclDataSourceType.
const (
	DepartureRtCnclDataSourceTypeARAMIS    DepartureRtCnclDataSourceType = "ARAMIS"
	DepartureRtCnclDataSourceTypeBLACKLIST DepartureRtCnclDataSourceType = "BLACKLIST"
	DepartureRtCnclDataSourceTypeDDS       DepartureRtCnclDataSourceType = "DDS"
	DepartureRtCnclDataSourceTypeDEFAULT   DepartureRtCnclDataSourceType = "DEFAULT"
	DepartureRtCnclDataSourceTypeFE        DepartureRtCnclDataSourceType = "FE"
	DepartureRtCnclDataSourceTypeFIS       DepartureRtCnclDataSourceType = "FIS"
	DepartureRtCnclDataSourceTypeGTFS      DepartureRtCnclDataSourceType = "GTFS"
	DepartureRtCnclDataSourceTypeHIM       DepartureRtCnclDataSourceType = "HIM"
	DepartureRtCnclDataSourceTypeHRC       DepartureRtCnclDataSourceType = "HRC"
	DepartureRtCnclDataSourceTypeHRX       DepartureRtCnclDataSourceType = "HRX"
	DepartureRtCnclDataSourceTypePAISA     DepartureRtCnclDataSourceType = "PAISA"
	DepartureRtCnclDataSourceTypeRTABO2    DepartureRtCnclDataSourceType = "RTABO_2"
	DepartureRtCnclDataSourceTypeSIRI      DepartureRtCnclDataSourceType = "SIRI"
	DepartureRtCnclDataSourceTypeUIC       DepartureRtCnclDataSourceType = "UIC"
	DepartureRtCnclDataSourceTypeVDV       DepartureRtCnclDataSourceType = "VDV"
)

// Defines values for EcoTypeType.
const (
	BEE EcoTypeType = "BEE"
	IMT EcoTypeType = "IMT"
	PFT EcoTypeType = "PFT"
	PRT EcoTypeType = "PRT"
	PTM EcoTypeType = "PTM"
	PUT EcoTypeType = "PUT"
)

// Defines values for GisRouteSegmentMan.
const (
	GisRouteSegmentManCH  GisRouteSegmentMan = "CH"
	GisRouteSegmentManCIF GisRouteSegmentMan = "CIF"
	GisRouteSegmentManCOF GisRouteSegmentMan = "COF"
	GisRouteSegmentManEF  GisRouteSegmentMan = "EF"
	GisRouteSegmentManEL  GisRouteSegmentMan = "EL"
	GisRouteSegmentManELD GisRouteSegmentMan = "ELD"
	GisRouteSegmentManELU GisRouteSegmentMan = "ELU"
	GisRouteSegmentManEN  GisRouteSegmentMan = "EN"
	GisRouteSegmentManER  GisRouteSegmentMan = "ER"
	GisRouteSegmentManES  GisRouteSegmentMan = "ES"
	GisRouteSegmentManESD GisRouteSegmentMan = "ESD"
	GisRouteSegmentManESU GisRouteSegmentMan = "ESU"
	GisRouteSegmentManFOC GisRouteSegmentMan = "FOC"
	GisRouteSegmentManFOL GisRouteSegmentMan = "FOL"
	GisRouteSegmentManFOR GisRouteSegmentMan = "FOR"
	GisRouteSegmentManFR  GisRouteSegmentMan = "FR"
	GisRouteSegmentManHL  GisRouteSegmentMan = "HL"
	GisRouteSegmentManHR  GisRouteSegmentMan = "HR"
	GisRouteSegmentManKHL GisRouteSegmentMan = "KHL"
	GisRouteSegmentManKHR GisRouteSegmentMan = "KHR"
	GisRouteSegmentManKL  GisRouteSegmentMan = "KL"
	GisRouteSegmentManKR  GisRouteSegmentMan = "KR"
	GisRouteSegmentManKSL GisRouteSegmentMan = "KSL"
	GisRouteSegmentManKSR GisRouteSegmentMan = "KSR"
	GisRouteSegmentManLE  GisRouteSegmentMan = "LE"
	GisRouteSegmentManLF  GisRouteSegmentMan = "LF"
	GisRouteSegmentManLR  GisRouteSegmentMan = "LR"
	GisRouteSegmentManLV  GisRouteSegmentMan = "LV"
	GisRouteSegmentManNO  GisRouteSegmentMan = "NO"
	GisRouteSegmentManON  GisRouteSegmentMan = "ON"
	GisRouteSegmentManRI  GisRouteSegmentMan = "RI"
	GisRouteSegmentManRL  GisRouteSegmentMan = "RL"
	GisRouteSegmentManRP  GisRouteSegmentMan = "RP"
	GisRouteSegmentManRR  GisRouteSegmentMan = "RR"
	GisRouteSegmentManSIR GisRouteSegmentMan = "SIR"
	GisRouteSegmentManSL  GisRouteSegmentMan = "SL"
	GisRouteSegmentManSR  GisRouteSegmentMan = "SR"
	GisRouteSegmentManST  GisRouteSegmentMan = "ST"
	GisRouteSegmentManSTA GisRouteSegmentMan = "STA"
	GisRouteSegmentManSTD GisRouteSegmentMan = "STD"
	GisRouteSegmentManSTU GisRouteSegmentMan = "STU"
	GisRouteSegmentManTLL GisRouteSegmentMan = "TLL"
	GisRouteSegmentManTLR GisRouteSegmentMan = "TLR"
	GisRouteSegmentManTO  GisRouteSegmentMan = "TO"
	GisRouteSegmentManTRL GisRouteSegmentMan = "TRL"
	GisRouteSegmentManTRR GisRouteSegmentMan = "TRR"
	GisRouteSegmentManUT  GisRouteSegmentMan = "UT"
)

// Defines values for GisRouteSegmentOri.
const (
	GisRouteSegmentOriE  GisRouteSegmentOri = "E"
	GisRouteSegmentOriN  GisRouteSegmentOri = "N"
	GisRouteSegmentOriNE GisRouteSegmentOri = "NE"
	GisRouteSegmentOriNW GisRouteSegmentOri = "NW"
	GisRouteSegmentOriS  GisRouteSegmentOri = "S"
	GisRouteSegmentOriSE GisRouteSegmentOri = "SE"
	GisRouteSegmentOriSW GisRouteSegmentOri = "SW"
	GisRouteSegmentOriU  GisRouteSegmentOri = "U"
	GisRouteSegmentOriW  GisRouteSegmentOri = "W"
)

// Defines values for GisRouteSegmentRType.
const (
	GisRouteSegmentRTypeB   GisRouteSegmentRType = "B"
	GisRouteSegmentRTypeC   GisRouteSegmentRType = "C"
	GisRouteSegmentRTypeCT  GisRouteSegmentRType = "CT"
	GisRouteSegmentRTypeCW  GisRouteSegmentRType = "CW"
	GisRouteSegmentRTypeF   GisRouteSegmentRType = "F"
	GisRouteSegmentRTypeH   GisRouteSegmentRType = "H"
	GisRouteSegmentRTypeM   GisRouteSegmentRType = "M"
	GisRouteSegmentRTypeNT  GisRouteSegmentRType = "NT"
	GisRouteSegmentRTypeR   GisRouteSegmentRType = "R"
	GisRouteSegmentRTypeT   GisRouteSegmentRType = "T"
	GisRouteSegmentRTypeT2L GisRouteSegmentRType = "T2L"
	GisRouteSegmentRTypeT4L GisRouteSegmentRType = "T4L"
	GisRouteSegmentRTypeTR  GisRouteSegmentRType = "TR"
	GisRouteSegmentRTypeU   GisRouteSegmentRType = "U"
	GisRouteSegmentRTypeW   GisRouteSegmentRType = "W"
)

// Defines values for IconTypeShape.
const (
	IconTypeShapeB   IconTypeShape = "B"
	IconTypeShapeC   IconTypeShape = "C"
	IconTypeShapeH   IconTypeShape = "H"
	IconTypeShapeR   IconTypeShape = "R"
	IconTypeShapeRES IconTypeShape = "RES"
	IconTypeShapeU   IconTypeShape = "U"
)

// Defines values for IconTypeStyle.
const (
	IconTypeStyleB  IconTypeStyle = "B"
	IconTypeStyleBI IconTypeStyle = "BI"
	IconTypeStyleI  IconTypeStyle = "I"
	IconTypeStyleN  IconTypeStyle = "N"
	IconTypeStyleU  IconTypeStyle = "U"
)

// Defines values for JourneyDetailJourneyStatus.
const (
	JourneyDetailJourneyStatusA JourneyDetailJourneyStatus = "A"
	JourneyDetailJourneyStatusP JourneyDetailJourneyStatus = "P"
	JourneyDetailJourneyStatusR JourneyDetailJourneyStatus = "R"
	JourneyDetailJourneyStatusS JourneyDetailJourneyStatus = "S"
)

// Defines values for JourneyDetailParallelJourneyLinkType.
const (
	JourneyDetailParallelJourneyLinkTypeLINKEDRT   JourneyDetailParallelJourneyLinkType = "LINKED_RT"
	JourneyDetailParallelJourneyLinkTypePLANNED    JourneyDetailParallelJourneyLinkType = "PLANNED"
	JourneyDetailParallelJourneyLinkTypeUNDEF      JourneyDetailParallelJourneyLinkType = "UNDEF"
	JourneyDetailParallelJourneyLinkTypeUNLINKEDRT JourneyDetailParallelJourneyLinkType = "UNLINKED_RT"
)

// Defines values for JourneyPathItemTypeState.
const (
	JourneyPathItemTypeStateA JourneyPathItemTypeState = "A"
	JourneyPathItemTypeStateB JourneyPathItemTypeState = "B"
	JourneyPathItemTypeStateO JourneyPathItemTypeState = "O"
	JourneyPathItemTypeStateU JourneyPathItemTypeState = "U"
)

// Defines values for JourneyTypeParallelJourneyLinkType.
const (
	JourneyTypeParallelJourneyLinkTypeLINKEDRT   JourneyTypeParallelJourneyLinkType = "LINKED_RT"
	JourneyTypeParallelJourneyLinkTypePLANNED    JourneyTypeParallelJourneyLinkType = "PLANNED"
	JourneyTypeParallelJourneyLinkTypeUNDEF      JourneyTypeParallelJourneyLinkType = "UNDEF"
	JourneyTypeParallelJourneyLinkTypeUNLINKEDRT JourneyTypeParallelJourneyLinkType = "UNLINKED_RT"
)

// Defines values for LegJourneyStatus.
const (
	LegJourneyStatusA LegJourneyStatus = "A"
	LegJourneyStatusP LegJourneyStatus = "P"
	LegJourneyStatusR LegJourneyStatus = "R"
	LegJourneyStatusS LegJourneyStatus = "S"
)

// Defines values for LegRecState.
const (
	LegRecStateC LegRecState = "C"
	LegRecStateN LegRecState = "N"
	LegRecStateO LegRecState = "O"
	LegRecStateP LegRecState = "P"
	LegRecStateU LegRecState = "U"
)

// Defines values for LegWaitingState.
const (
	LegWaitingStateNOWAIT LegWaitingState = "NOWAIT"
	LegWaitingStateUNDEF  LegWaitingState = "UNDEF"
	LegWaitingStateWAIT   LegWaitingState = "WAIT"
)

// Defines values for LocationNoteType.
const (
	LocationNoteTypeA   LocationNoteType = "A"
	LocationNoteTypeB   LocationNoteType = "B"
	LocationNoteTypeC   LocationNoteType = "C"
	LocationNoteTypeD   LocationNoteType = "D"
	LocationNoteTypeED  LocationNoteType = "ED"
	LocationNoteTypeFN  LocationNoteType = "FN"
	LocationNoteTypeG   LocationNoteType = "G"
	LocationNoteTypeH   LocationNoteType = "H"
	LocationNoteTypeI   LocationNoteType = "I"
	LocationNoteTypeK   LocationNoteType = "K"
	LocationNoteTypeL   LocationNoteType = "L"
	LocationNoteTypeLNC LocationNoteType = "LNC"
	LocationNoteTypeM   LocationNoteType = "M"
	LocationNoteTypeN   LocationNoteType = "N"
	LocationNoteTypeO   LocationNoteType = "O"
	LocationNoteTypeP   LocationNoteType = "P"
	LocationNoteTypeQ   LocationNoteType = "Q"
	LocationNoteTypeR   LocationNoteType = "R"
	LocationNoteTypeS   LocationNoteType = "S"
	LocationNoteTypeTAR LocationNoteType = "TAR"
	LocationNoteTypeTLN LocationNoteType = "TLN"
	LocationNoteTypeU   LocationNoteType = "U"
	LocationNoteTypeV   LocationNoteType = "V"
	LocationNoteTypeW   LocationNoteType = "W"
	LocationNoteTypeX   LocationNoteType = "X"
	LocationNoteTypeY   LocationNoteType = "Y"
	LocationNoteTypeZ   LocationNoteType = "Z"
)

// Defines values for McpAvailabilityTypeEndBoundaryType.
const (
	McpAvailabilityTypeEndBoundaryTypeEXCLUSIVE McpAvailabilityTypeEndBoundaryType = "EXCLUSIVE"
	McpAvailabilityTypeEndBoundaryTypeINCLUSIVE McpAvailabilityTypeEndBoundaryType = "INCLUSIVE"
)

// Defines values for McpAvailabilityTypeIntervalLimitation.
const (
	NONE           McpAvailabilityTypeIntervalLimitation = "NONE"
	PUBLICHOLIDAYS McpAvailabilityTypeIntervalLimitation = "PUBLIC_HOLIDAYS"
	SCHOOLHOLIDAYS McpAvailabilityTypeIntervalLimitation = "SCHOOL_HOLIDAYS"
)

// Defines values for McpAvailabilityTypeStartBoundaryType.
const (
	McpAvailabilityTypeStartBoundaryTypeEXCLUSIVE McpAvailabilityTypeStartBoundaryType = "EXCLUSIVE"
	McpAvailabilityTypeStartBoundaryTypeINCLUSIVE McpAvailabilityTypeStartBoundaryType = "INCLUSIVE"
)

// Defines values for McpInformationTypeOccupancy.
const (
	McpInformationTypeOccupancyA McpInformationTypeOccupancy = "A"
	McpInformationTypeOccupancyE McpInformationTypeOccupancy = "E"
	McpInformationTypeOccupancyN McpInformationTypeOccupancy = "N"
	McpInformationTypeOccupancyU McpInformationTypeOccupancy = "U"
)

// Defines values for McpInformationTypePhysicalAccessType.
const (
	McpInformationTypePhysicalAccessTypeENTRYANDEXIT McpInformationTypePhysicalAccessType = "ENTRY_AND_EXIT"
	McpInformationTypePhysicalAccessTypeENTRYONLY    McpInformationTypePhysicalAccessType = "ENTRY_ONLY"
	McpInformationTypePhysicalAccessTypeEXITONLY     McpInformationTypePhysicalAccessType = "EXIT_ONLY"
	McpInformationTypePhysicalAccessTypeUNDEF        McpInformationTypePhysicalAccessType = "UNDEF"
)

// Defines values for McpInformationTypeType.
const (
	McpInformationTypeTypeA  McpInformationTypeType = "A"
	McpInformationTypeTypeH  McpInformationTypeType = "H"
	McpInformationTypeTypeP  McpInformationTypeType = "P"
	McpInformationTypeTypePA McpInformationTypeType = "PA"
	McpInformationTypeTypeU  McpInformationTypeType = "U"
	McpInformationTypeTypeV  McpInformationTypeType = "V"
)

// Defines values for McpModalityTypePlaceType.
const (
	McpModalityTypePlaceTypeCHARGE McpModalityTypePlaceType = "CHARGE"
	McpModalityTypePlaceTypeFIX    McpModalityTypePlaceType = "FIX"
	McpModalityTypePlaceTypeFLEX   McpModalityTypePlaceType = "FLEX"
	McpModalityTypePlaceTypeFREE   McpModalityTypePlaceType = "FREE"
	McpModalityTypePlaceTypeRETURN McpModalityTypePlaceType = "RETURN"
	McpModalityTypePlaceTypeRIDE   McpModalityTypePlaceType = "RIDE"
	McpModalityTypePlaceTypeUNDEF  McpModalityTypePlaceType = "UNDEF"
)

// Defines values for McpModalityTypeTransportMode.
const (
	McpModalityTypeTransportModeBIKE  McpModalityTypeTransportMode = "BIKE"
	McpModalityTypeTransportModeCAR   McpModalityTypeTransportMode = "CAR"
	McpModalityTypeTransportModeUNDEF McpModalityTypeTransportMode = "UNDEF"
	McpModalityTypeTransportModeWALK  McpModalityTypeTransportMode = "WALK"
)

// Defines values for McpModalityTypeUsageType.
const (
	McpModalityTypeUsageTypeO McpModalityTypeUsageType = "O"
	McpModalityTypeUsageTypeP McpModalityTypeUsageType = "P"
	McpModalityTypeUsageTypeR McpModalityTypeUsageType = "R"
	McpModalityTypeUsageTypeS McpModalityTypeUsageType = "S"
	McpModalityTypeUsageTypeT McpModalityTypeUsageType = "T"
	McpModalityTypeUsageTypeU McpModalityTypeUsageType = "U"
)

// Defines values for MessageBaseType.
const (
	MessageBaseTypeGLOBAL         MessageBaseType = "GLOBAL"
	MessageBaseTypeINFRASTRUCTURE MessageBaseType = "INFRASTRUCTURE"
	MessageBaseTypeUNDEF          MessageBaseType = "UNDEF"
)

// Defines values for NoteType.
const (
	NoteTypeA   NoteType = "A"
	NoteTypeB   NoteType = "B"
	NoteTypeC   NoteType = "C"
	NoteTypeD   NoteType = "D"
	NoteTypeED  NoteType = "ED"
	NoteTypeFN  NoteType = "FN"
	NoteTypeG   NoteType = "G"
	NoteTypeH   NoteType = "H"
	NoteTypeI   NoteType = "I"
	NoteTypeK   NoteType = "K"
	NoteTypeL   NoteType = "L"
	NoteTypeLNC NoteType = "LNC"
	NoteTypeM   NoteType = "M"
	NoteTypeN   NoteType = "N"
	NoteTypeO   NoteType = "O"
	NoteTypeP   NoteType = "P"
	NoteTypeQ   NoteType = "Q"
	NoteTypeR   NoteType = "R"
	NoteTypeS   NoteType = "S"
	NoteTypeTAR NoteType = "TAR"
	NoteTypeTLN NoteType = "TLN"
	NoteTypeU   NoteType = "U"
	NoteTypeV   NoteType = "V"
	NoteTypeW   NoteType = "W"
	NoteTypeX   NoteType = "X"
	NoteTypeY   NoteType = "Y"
	NoteTypeZ   NoteType = "Z"
)

// Defines values for OriginDestTypePrognosisType.
const (
	OriginDestTypePrognosisTypeCALCULATED OriginDestTypePrognosisType = "CALCULATED"
	OriginDestTypePrognosisTypeCORRECTED  OriginDestTypePrognosisType = "CORRECTED"
	OriginDestTypePrognosisTypeMANUAL     OriginDestTypePrognosisType = "MANUAL"
	OriginDestTypePrognosisTypePROGNOSED  OriginDestTypePrognosisType = "PROGNOSED"
	OriginDestTypePrognosisTypeREPORTED   OriginDestTypePrognosisType = "REPORTED"
)

// Defines values for OriginDestTypeRtCnclDataSourceType.
const (
	OriginDestTypeRtCnclDataSourceTypeARAMIS    OriginDestTypeRtCnclDataSourceType = "ARAMIS"
	OriginDestTypeRtCnclDataSourceTypeBLACKLIST OriginDestTypeRtCnclDataSourceType = "BLACKLIST"
	OriginDestTypeRtCnclDataSourceTypeDDS       OriginDestTypeRtCnclDataSourceType = "DDS"
	OriginDestTypeRtCnclDataSourceTypeDEFAULT   OriginDestTypeRtCnclDataSourceType = "DEFAULT"
	OriginDestTypeRtCnclDataSourceTypeFE        OriginDestTypeRtCnclDataSourceType = "FE"
	OriginDestTypeRtCnclDataSourceTypeFIS       OriginDestTypeRtCnclDataSourceType = "FIS"
	OriginDestTypeRtCnclDataSourceTypeGTFS      OriginDestTypeRtCnclDataSourceType = "GTFS"
	OriginDestTypeRtCnclDataSourceTypeHIM       OriginDestTypeRtCnclDataSourceType = "HIM"
	OriginDestTypeRtCnclDataSourceTypeHRC       OriginDestTypeRtCnclDataSourceType = "HRC"
	OriginDestTypeRtCnclDataSourceTypeHRX       OriginDestTypeRtCnclDataSourceType = "HRX"
	OriginDestTypeRtCnclDataSourceTypePAISA     OriginDestTypeRtCnclDataSourceType = "PAISA"
	OriginDestTypeRtCnclDataSourceTypeRTABO2    OriginDestTypeRtCnclDataSourceType = "RTABO_2"
	OriginDestTypeRtCnclDataSourceTypeSIRI      OriginDestTypeRtCnclDataSourceType = "SIRI"
	OriginDestTypeRtCnclDataSourceTypeUIC       OriginDestTypeRtCnclDataSourceType = "UIC"
	OriginDestTypeRtCnclDataSourceTypeVDV       OriginDestTypeRtCnclDataSourceType = "VDV"
)

// Defines values for ParallelJourneyRefTypeLinkType.
const (
	ParallelJourneyRefTypeLinkTypeLINKEDRT   ParallelJourneyRefTypeLinkType = "LINKED_RT"
	ParallelJourneyRefTypeLinkTypePLANNED    ParallelJourneyRefTypeLinkType = "PLANNED"
	ParallelJourneyRefTypeLinkTypeUNDEF      ParallelJourneyRefTypeLinkType = "UNDEF"
	ParallelJourneyRefTypeLinkTypeUNLINKEDRT ParallelJourneyRefTypeLinkType = "UNLINKED_RT"
)

// Defines values for ParallelJourneyRefTypeType.
const (
	ParallelJourneyRefTypeTypeTHROUGHCOACH ParallelJourneyRefTypeType = "THROUGHCOACH"
	ParallelJourneyRefTypeTypeTIETHROUGH   ParallelJourneyRefTypeType = "TIETHROUGH"
	ParallelJourneyRefTypeTypeUNDEF        ParallelJourneyRefTypeType = "UNDEF"
	ParallelJourneyRefTypeTypeUNION        ParallelJourneyRefTypeType = "UNION"
)

// Defines values for PlatformTypeType.
const (
	PlatformTypeTypeCI PlatformTypeType = "CI"
	PlatformTypeTypeCO PlatformTypeType = "CO"
	PlatformTypeTypeFL PlatformTypeType = "FL"
	PlatformTypeTypeGA PlatformTypeType = "GA"
	PlatformTypeTypeH  PlatformTypeType = "H"
	PlatformTypeTypePI PlatformTypeType = "PI"
	PlatformTypeTypePL PlatformTypeType = "PL"
	PlatformTypeTypeSL PlatformTypeType = "SL"
	PlatformTypeTypeST PlatformTypeType = "ST"
	PlatformTypeTypeU  PlatformTypeType = "U"
	PlatformTypeTypeX  PlatformTypeType = "X"
)

// Defines values for PolylineType.
const (
	PolylineTypeHAFASGEO PolylineType = "HAFASGEO"
	PolylineTypePLANAR   PolylineType = "PLANAR"
	PolylineTypeWGS84    PolylineType = "WGS84"
)

// Defines values for PolylineGroupCoordType.
const (
	PolylineGroupCoordTypeHAFASGEO PolylineGroupCoordType = "HAFASGEO"
	PolylineGroupCoordTypePLANAR   PolylineGroupCoordType = "PLANAR"
	PolylineGroupCoordTypeWGS84    PolylineGroupCoordType = "WGS84"
)

// Defines values for ReferencedJourneyTypeType.
const (
	ReferencedJourneyTypeTypeDEFAULT                              ReferencedJourneyTypeType = "DEFAULT"
	ReferencedJourneyTypeTypeDEFAULTR                             ReferencedJourneyTypeType = "DEFAULT_R"
	ReferencedJourneyTypeTypeHATENTLASTUNG                        ReferencedJourneyTypeType = "HAT_ENTLASTUNG"
	ReferencedJourneyTypeTypeHATERSATZFAHRT                       ReferencedJourneyTypeType = "HAT_ERSATZFAHRT"
	ReferencedJourneyTypeTypeHATFORTFUEHRUNG                      ReferencedJourneyTypeType = "HAT_FORTFUEHRUNG"
	ReferencedJourneyTypeTypeHATFORTFUEHRUNGDURCHZUSAMMENFUEHRUNG ReferencedJourneyTypeType = "HAT_FORTFUEHRUNG_DURCH_ZUSAMMENFUEHRUNG"
	ReferencedJourneyTypeTypeHATFORTFUEHRUNGVONTRENNUNG           ReferencedJourneyTypeType = "HAT_FORTFUEHRUNG_VON_TRENNUNG"
	ReferencedJourneyTypeTypeHATTRENNUNG                          ReferencedJourneyTypeType = "HAT_TRENNUNG"
	ReferencedJourneyTypeTypeHATVERSTAERKERFAHRT                  ReferencedJourneyTypeType = "HAT_VERSTAERKERFAHRT"
	ReferencedJourneyTypeTypeHATZUSAMMENFUEHRUNG                  ReferencedJourneyTypeType = "HAT_ZUSAMMENFUEHRUNG"
	ReferencedJourneyTypeTypeISTENTLASTUNG                        ReferencedJourneyTypeType = "IST_ENTLASTUNG"
	ReferencedJourneyTypeTypeISTERSATZFAHRT                       ReferencedJourneyTypeType = "IST_ERSATZFAHRT"
	ReferencedJourneyTypeTypeISTFORTFUEHRUNG                      ReferencedJourneyTypeType = "IST_FORTFUEHRUNG"
	ReferencedJourneyTypeTypeISTFORTFUEHRUNGDURCHZUSAMMENFUEHRUNG ReferencedJourneyTypeType = "IST_FORTFUEHRUNG_DURCH_ZUSAMMENFUEHRUNG"
	ReferencedJourneyTypeTypeISTFORTFUEHRUNGVONTRENNUNG           ReferencedJourneyTypeType = "IST_FORTFUEHRUNG_VON_TRENNUNG"
	ReferencedJourneyTypeTypeISTTRENNUNG                          ReferencedJourneyTypeType = "IST_TRENNUNG"
	ReferencedJourneyTypeTypeISTVERSTAERKERFAHRT                  ReferencedJourneyTypeType = "IST_VERSTAERKERFAHRT"
	ReferencedJourneyTypeTypeISTZUSAMMENFUEHRUNG                  ReferencedJourneyTypeType = "IST_ZUSAMMENFUEHRUNG"
	ReferencedJourneyTypeTypeUNDEF                                ReferencedJourneyTypeType = "UNDEF"
)

// Defines values for SortingGroupTypeType.
const (
	SortingGroupTypeTypeAT  SortingGroupTypeType = "AT"
	SortingGroupTypeTypeCAL SortingGroupTypeType = "CAL"
	SortingGroupTypeTypeCF  SortingGroupTypeType = "CF"
	SortingGroupTypeTypeCO  SortingGroupTypeType = "CO"
	SortingGroupTypeTypeCO2 SortingGroupTypeType = "CO2"
	SortingGroupTypeTypeDT  SortingGroupTypeType = "DT"
	SortingGroupTypeTypeOC  SortingGroupTypeType = "OC"
	SortingGroupTypeTypePT  SortingGroupTypeType = "PT"
	SortingGroupTypeTypeTI  SortingGroupTypeType = "TI"
	SortingGroupTypeTypeUT  SortingGroupTypeType = "UT"
)

// Defines values for SortingTypeInitialSortingType.
const (
	SortingTypeInitialSortingTypeAT  SortingTypeInitialSortingType = "AT"
	SortingTypeInitialSortingTypeCAL SortingTypeInitialSortingType = "CAL"
	SortingTypeInitialSortingTypeCF  SortingTypeInitialSortingType = "CF"
	SortingTypeInitialSortingTypeCO  SortingTypeInitialSortingType = "CO"
	SortingTypeInitialSortingTypeCO2 SortingTypeInitialSortingType = "CO2"
	SortingTypeInitialSortingTypeDT  SortingTypeInitialSortingType = "DT"
	SortingTypeInitialSortingTypeOC  SortingTypeInitialSortingType = "OC"
	SortingTypeInitialSortingTypePT  SortingTypeInitialSortingType = "PT"
	SortingTypeInitialSortingTypeTI  SortingTypeInitialSortingType = "TI"
	SortingTypeInitialSortingTypeUT  SortingTypeInitialSortingType = "UT"
)

// Defines values for SotContextTypeLocMode.
const (
	ATCHANGESTOP                    SotContextTypeLocMode = "AT_CHANGE_STOP"
	ATDESTINATION                   SotContextTypeLocMode = "AT_DESTINATION"
	ATLASTUSABLESTOP                SotContextTypeLocMode = "AT_LAST_USABLE_STOP"
	ATPASSEDSTOP                    SotContextTypeLocMode = "AT_PASSED_STOP"
	BEFORETRAVEL                    SotContextTypeLocMode = "BEFORE_TRAVEL"
	CHECKCOMPLETETRAIN              SotContextTypeLocMode = "CHECK_COMPLETE_TRAIN"
	ERROR                           SotContextTypeLocMode = "ERROR"
	ERRORALLTRAINSFILTERED          SotContextTypeLocMode = "ERROR_ALL_TRAINS_FILTERED"
	ERRORINRECONSTRUCTION           SotContextTypeLocMode = "ERROR_IN_RECONSTRUCTION"
	ERRORSEARCHFROMTRAINBEFORESTART SotContextTypeLocMode = "ERROR_SEARCH_FROM_TRAIN_BEFORE_START"
	ERRORSTAYINCURRENTCONNECTION    SotContextTypeLocMode = "ERROR_STAY_IN_CURRENT_CONNECTION"
	ERRORTRAINCANCELLED             SotContextTypeLocMode = "ERROR_TRAIN_CANCELLED"
	FROMSTART                       SotContextTypeLocMode = "FROM_START"
	INTRAIN                         SotContextTypeLocMode = "IN_TRAIN"
	TOBEDEFINEDINSERVER             SotContextTypeLocMode = "TO_BE_DEFINED_IN_SERVER"
	UNKNOWN                         SotContextTypeLocMode = "UNKNOWN"
)

// Defines values for StopTypeArrPrognosisType.
const (
	StopTypeArrPrognosisTypeCALCULATED StopTypeArrPrognosisType = "CALCULATED"
	StopTypeArrPrognosisTypeCORRECTED  StopTypeArrPrognosisType = "CORRECTED"
	StopTypeArrPrognosisTypeMANUAL     StopTypeArrPrognosisType = "MANUAL"
	StopTypeArrPrognosisTypePROGNOSED  StopTypeArrPrognosisType = "PROGNOSED"
	StopTypeArrPrognosisTypeREPORTED   StopTypeArrPrognosisType = "REPORTED"
)

// Defines values for StopTypeDepPrognosisType.
const (
	CALCULATED StopTypeDepPrognosisType = "CALCULATED"
	CORRECTED  StopTypeDepPrognosisType = "CORRECTED"
	MANUAL     StopTypeDepPrognosisType = "MANUAL"
	PROGNOSED  StopTypeDepPrognosisType = "PROGNOSED"
	REPORTED   StopTypeDepPrognosisType = "REPORTED"
)

// Defines values for StopTypeRtCnclDataSourceType.
const (
	ARAMIS    StopTypeRtCnclDataSourceType = "ARAMIS"
	BLACKLIST StopTypeRtCnclDataSourceType = "BLACKLIST"
	DDS       StopTypeRtCnclDataSourceType = "DDS"
	DEFAULT   StopTypeRtCnclDataSourceType = "DEFAULT"
	FE        StopTypeRtCnclDataSourceType = "FE"
	FIS       StopTypeRtCnclDataSourceType = "FIS"
	GTFS      StopTypeRtCnclDataSourceType = "GTFS"
	HIM       StopTypeRtCnclDataSourceType = "HIM"
	HRC       StopTypeRtCnclDataSourceType = "HRC"
	HRX       StopTypeRtCnclDataSourceType = "HRX"
	PAISA     StopTypeRtCnclDataSourceType = "PAISA"
	RTABO2    StopTypeRtCnclDataSourceType = "RTABO_2"
	SIRI      StopTypeRtCnclDataSourceType = "SIRI"
	UIC       StopTypeRtCnclDataSourceType = "UIC"
	VDV       StopTypeRtCnclDataSourceType = "VDV"
)

// Defines values for TrafficMessageTypeType.
const (
	TrafficMessageTypeTypeAC                    TrafficMessageTypeType = "AC"
	TrafficMessageTypeTypeACCESSRESTRICTION     TrafficMessageTypeType = "ACCESS_RESTRICTION"
	TrafficMessageTypeTypeACCIDENT              TrafficMessageTypeType = "ACCIDENT"
	TrafficMessageTypeTypeAT                    TrafficMessageTypeType = "AT"
	TrafficMessageTypeTypeBURNINGVEHICLE        TrafficMessageTypeType = "BURNING_VEHICLE"
	TrafficMessageTypeTypeCO                    TrafficMessageTypeType = "CO"
	TrafficMessageTypeTypeCONSTRUCTIONSITE      TrafficMessageTypeType = "CONSTRUCTION_SITE"
	TrafficMessageTypeTypeDANGER                TrafficMessageTypeType = "DANGER"
	TrafficMessageTypeTypeDELAY                 TrafficMessageTypeType = "DELAY"
	TrafficMessageTypeTypeGENERIC               TrafficMessageTypeType = "GENERIC"
	TrafficMessageTypeTypeJUNCTIONCLOSED        TrafficMessageTypeType = "JUNCTION_CLOSED"
	TrafficMessageTypeTypeLANECLOSED            TrafficMessageTypeType = "LANE_CLOSED"
	TrafficMessageTypeTypeOBSTRUCTION           TrafficMessageTypeType = "OBSTRUCTION"
	TrafficMessageTypeTypeRAILROADCROSSING      TrafficMessageTypeType = "RAIL_ROAD_CROSSING"
	TrafficMessageTypeTypeRCLM                  TrafficMessageTypeType = "RCLM"
	TrafficMessageTypeTypeREROUTING             TrafficMessageTypeType = "REROUTING"
	TrafficMessageTypeTypeROADCLOSED            TrafficMessageTypeType = "ROAD_CLOSED"
	TrafficMessageTypeTypeRW                    TrafficMessageTypeType = "RW"
	TrafficMessageTypeTypeTRAFFICJAM            TrafficMessageTypeType = "TRAFFIC_JAM"
	TrafficMessageTypeTypeTRAFFICLIGHTSDEFECT   TrafficMessageTypeType = "TRAFFIC_LIGHTS_DEFECT"
	TrafficMessageTypeTypeU                     TrafficMessageTypeType = "U"
	TrafficMessageTypeTypeWEATHER               TrafficMessageTypeType = "WEATHER"
	TrafficMessageTypeTypeWEATHERHAIL           TrafficMessageTypeType = "WEATHER_HAIL"
	TrafficMessageTypeTypeWEATHERICE            TrafficMessageTypeType = "WEATHER_ICE"
	TrafficMessageTypeTypeWEATHERPOORVISIBILITY TrafficMessageTypeType = "WEATHER_POOR_VISIBILITY"
	TrafficMessageTypeTypeWEATHERSNOW           TrafficMessageTypeType = "WEATHER_SNOW"
	TrafficMessageTypeTypeWEATHERWIND           TrafficMessageTypeType = "WEATHER_WIND"
)

// Defines values for TripTypeCalculation.
const (
	INITIAL                    TripTypeCalculation = "INITIAL"
	RETRYDOUBLERADIUS          TripTypeCalculation = "RETRY_DOUBLE_RADIUS"
	RETRYPRESELECTIONNEWRADIUS TripTypeCalculation = "RETRY_PRESELECTION_NEW_RADIUS"
	RETRYSHARP                 TripTypeCalculation = "RETRY_SHARP"
	RETRYUNSHARP               TripTypeCalculation = "RETRY_UNSHARP"
	RETRYUNSHARPNEWRADIUS      TripTypeCalculation = "RETRY_UNSHARP_NEW_RADIUS"
)

// Defines values for WeatherInformationTypeType.
const (
	WeatherInformationTypeTypeCLEAR            WeatherInformationTypeType = "CLEAR"
	WeatherInformationTypeTypeCLOUDY           WeatherInformationTypeType = "CLOUDY"
	WeatherInformationTypeTypeDRIZZLE          WeatherInformationTypeType = "DRIZZLE"
	WeatherInformationTypeTypeDRY              WeatherInformationTypeType = "DRY"
	WeatherInformationTypeTypeFOG              WeatherInformationTypeType = "FOG"
	WeatherInformationTypeTypeHAIL             WeatherInformationTypeType = "HAIL"
	WeatherInformationTypeTypeHEAVYFOG         WeatherInformationTypeType = "HEAVY_FOG"
	WeatherInformationTypeTypeHEAVYHAIL        WeatherInformationTypeType = "HEAVY_HAIL"
	WeatherInformationTypeTypeHEAVYRAIN        WeatherInformationTypeType = "HEAVY_RAIN"
	WeatherInformationTypeTypeHEAVYSANDSTORM   WeatherInformationTypeType = "HEAVY_SANDSTORM"
	WeatherInformationTypeTypeHEAVYSNOW        WeatherInformationTypeType = "HEAVY_SNOW"
	WeatherInformationTypeTypeLIGHTRAIN        WeatherInformationTypeType = "LIGHT_RAIN"
	WeatherInformationTypeTypePARTIALLYCLOUDY  WeatherInformationTypeType = "PARTIALLY_CLOUDY"
	WeatherInformationTypeTypeRAIN             WeatherInformationTypeType = "RAIN"
	WeatherInformationTypeTypeRAINSHOWER       WeatherInformationTypeType = "RAIN_SHOWER"
	WeatherInformationTypeTypeSANDSTORM        WeatherInformationTypeType = "SANDSTORM"
	WeatherInformationTypeTypeSLEET            WeatherInformationTypeType = "SLEET"
	WeatherInformationTypeTypeSLEETSHOWER      WeatherInformationTypeType = "SLEET_SHOWER"
	WeatherInformationTypeTypeSLIGHTLYCLOUDY   WeatherInformationTypeType = "SLIGHTLY_CLOUDY"
	WeatherInformationTypeTypeSLIPPERYROAD     WeatherInformationTypeType = "SLIPPERY_ROAD"
	WeatherInformationTypeTypeSNOW             WeatherInformationTypeType = "SNOW"
	WeatherInformationTypeTypeSNOWSHOWER       WeatherInformationTypeType = "SNOW_SHOWER"
	WeatherInformationTypeTypeSTORM            WeatherInformationTypeType = "STORM"
	WeatherInformationTypeTypeTHUNDERSANDSTORM WeatherInformationTypeType = "THUNDER_SANDSTORM"
	WeatherInformationTypeTypeTHUNDERSTORM     WeatherInformationTypeType = "THUNDERSTORM"
	WeatherInformationTypeTypeUNDEF            WeatherInformationTypeType = "UNDEF"
	WeatherInformationTypeTypeWETANDCOLD       WeatherInformationTypeType = "WET_AND_COLD"
)

// Defines values for Verb1ParamsFormat.
const (
	Verb1ParamsFormatJson  Verb1ParamsFormat = "json"
	Verb1ParamsFormatJsonp Verb1ParamsFormat = "jsonp"
	Verb1ParamsFormatXml   Verb1ParamsFormat = "xml"
)

// Defines values for Verb1ParamsPasslist.
const (
	Verb1ParamsPasslistN0 Verb1ParamsPasslist = "0"
	Verb1ParamsPasslistN1 Verb1ParamsPasslist = "1"
)

// Defines values for Verb1ParamsBaim.
const (
	Verb1ParamsBaimN0 Verb1ParamsBaim = "0"
	Verb1ParamsBaimN1 Verb1ParamsBaim = "1"
)

// Defines values for Verb1ParamsRtMode.
const (
	Verb1ParamsRtModeOFF           Verb1ParamsRtMode = "OFF"
	Verb1ParamsRtModeSERVERDEFAULT Verb1ParamsRtMode = "SERVER_DEFAULT"
)

// Defines values for Verb1ParamsType.
const (
	ARR        Verb1ParamsType = "ARR"
	ARREQUIVS  Verb1ParamsType = "ARR_EQUIVS"
	ARRMAST    Verb1ParamsType = "ARR_MAST"
	ARRSTATION Verb1ParamsType = "ARR_STATION"
)

// Defines values for Verb2ParamsFormat.
const (
	Verb2ParamsFormatJson  Verb2ParamsFormat = "json"
	Verb2ParamsFormatJsonp Verb2ParamsFormat = "jsonp"
	Verb2ParamsFormatXml   Verb2ParamsFormat = "xml"
)

// Defines values for Verb3ParamsFormat.
const (
	Verb3ParamsFormatJson  Verb3ParamsFormat = "json"
	Verb3ParamsFormatJsonp Verb3ParamsFormat = "jsonp"
	Verb3ParamsFormatXml   Verb3ParamsFormat = "xml"
)

// Defines values for Verb3ParamsPasslist.
const (
	Verb3ParamsPasslistN0 Verb3ParamsPasslist = "0"
	Verb3ParamsPasslistN1 Verb3ParamsPasslist = "1"
)

// Defines values for Verb3ParamsBaim.
const (
	Verb3ParamsBaimN0 Verb3ParamsBaim = "0"
	Verb3ParamsBaimN1 Verb3ParamsBaim = "1"
)

// Defines values for Verb3ParamsRtMode.
const (
	Verb3ParamsRtModeOFF           Verb3ParamsRtMode = "OFF"
	Verb3ParamsRtModeSERVERDEFAULT Verb3ParamsRtMode = "SERVER_DEFAULT"
)

// Defines values for Verb3ParamsType.
const (
	DEP        Verb3ParamsType = "DEP"
	DEPEQUIVS  Verb3ParamsType = "DEP_EQUIVS"
	DEPMAST    Verb3ParamsType = "DEP_MAST"
	DEPSTATION Verb3ParamsType = "DEP_STATION"
)

// Defines values for Verb4ParamsFormat.
const (
	Verb4ParamsFormatJson  Verb4ParamsFormat = "json"
	Verb4ParamsFormatJsonp Verb4ParamsFormat = "jsonp"
	Verb4ParamsFormatXml   Verb4ParamsFormat = "xml"
)

// Defines values for Verb4ParamsPoly.
const (
	Verb4ParamsPolyN0 Verb4ParamsPoly = "0"
	Verb4ParamsPolyN1 Verb4ParamsPoly = "1"
)

// Defines values for Verb4ParamsPolyEnc.
const (
	Verb4ParamsPolyEncDLT Verb4ParamsPolyEnc = "DLT"
	Verb4ParamsPolyEncGPA Verb4ParamsPolyEnc = "GPA"
	Verb4ParamsPolyEncN   Verb4ParamsPolyEnc = "N"
)

// Defines values for Verb4ParamsEco.
const (
	Verb4ParamsEcoN0 Verb4ParamsEco = "0"
	Verb4ParamsEcoN1 Verb4ParamsEco = "1"
)

// Defines values for Verb4ParamsBaim.
const (
	Verb4ParamsBaimN0 Verb4ParamsBaim = "0"
	Verb4ParamsBaimN1 Verb4ParamsBaim = "1"
)

// Defines values for Verb5ParamsFormat.
const (
	Verb5ParamsFormatJson  Verb5ParamsFormat = "json"
	Verb5ParamsFormatJsonp Verb5ParamsFormat = "jsonp"
	Verb5ParamsFormatXml   Verb5ParamsFormat = "xml"
)

// Defines values for Verb5ParamsHierarchicalView.
const (
	Verb5ParamsHierarchicalViewN0 Verb5ParamsHierarchicalView = "0"
	Verb5ParamsHierarchicalViewN1 Verb5ParamsHierarchicalView = "1"
)

// Defines values for Verb5ParamsBothways.
const (
	Verb5ParamsBothwaysN0 Verb5ParamsBothways = "0"
	Verb5ParamsBothwaysN1 Verb5ParamsBothways = "1"
)

// Defines values for Verb5ParamsPoly.
const (
	Verb5ParamsPolyN0 Verb5ParamsPoly = "0"
	Verb5ParamsPolyN1 Verb5ParamsPoly = "1"
)

// Defines values for Verb5ParamsSearchmode.
const (
	MATCH   Verb5ParamsSearchmode = "MATCH"
	NOMATCH Verb5ParamsSearchmode = "NOMATCH"
	TFMATCH Verb5ParamsSearchmode = "TFMATCH"
)

// Defines values for Verb5ParamsAffectedJourneyMode.
const (
	Verb5ParamsAffectedJourneyModeALL Verb5ParamsAffectedJourneyMode = "ALL"
	Verb5ParamsAffectedJourneyModeOFF Verb5ParamsAffectedJourneyMode = "OFF"
)

// Defines values for Verb5ParamsAffectedJourneyStopMode.
const (
	Verb5ParamsAffectedJourneyStopModeALL Verb5ParamsAffectedJourneyStopMode = "ALL"
	Verb5ParamsAffectedJourneyStopModeIMP Verb5ParamsAffectedJourneyStopMode = "IMP"
	Verb5ParamsAffectedJourneyStopModeOFF Verb5ParamsAffectedJourneyStopMode = "OFF"
)

// Defines values for Verb6ParamsFormat.
const (
	Verb6ParamsFormatJson  Verb6ParamsFormat = "json"
	Verb6ParamsFormatJsonp Verb6ParamsFormat = "jsonp"
	Verb6ParamsFormatXml   Verb6ParamsFormat = "xml"
)

// Defines values for Verb6ParamsPoly.
const (
	Verb6ParamsPolyN0 Verb6ParamsPoly = "0"
	Verb6ParamsPolyN1 Verb6ParamsPoly = "1"
)

// Defines values for Verb6ParamsPolyEnc.
const (
	Verb6ParamsPolyEncDLT Verb6ParamsPolyEnc = "DLT"
	Verb6ParamsPolyEncGPA Verb6ParamsPolyEnc = "GPA"
	Verb6ParamsPolyEncN   Verb6ParamsPolyEnc = "N"
)

// Defines values for Verb6ParamsShowPassingPoints.
const (
	Verb6ParamsShowPassingPointsN0 Verb6ParamsShowPassingPoints = "0"
	Verb6ParamsShowPassingPointsN1 Verb6ParamsShowPassingPoints = "1"
)

// Defines values for Verb6ParamsRtMode.
const (
	Verb6ParamsRtModeFULL          Verb6ParamsRtMode = "FULL"
	Verb6ParamsRtModeINFOS         Verb6ParamsRtMode = "INFOS"
	Verb6ParamsRtModeOFF           Verb6ParamsRtMode = "OFF"
	Verb6ParamsRtModeREALTIME      Verb6ParamsRtMode = "REALTIME"
	Verb6ParamsRtModeSERVERDEFAULT Verb6ParamsRtMode = "SERVER_DEFAULT"
)

// Defines values for Verb6ParamsBaim.
const (
	Verb6ParamsBaimN0 Verb6ParamsBaim = "0"
	Verb6ParamsBaimN1 Verb6ParamsBaim = "1"
)

// Defines values for Verb7ParamsFormat.
const (
	Verb7ParamsFormatJson  Verb7ParamsFormat = "json"
	Verb7ParamsFormatJsonp Verb7ParamsFormat = "jsonp"
	Verb7ParamsFormatXml   Verb7ParamsFormat = "xml"
)

// Defines values for Verb7ParamsPositionMode.
const (
	CALC       Verb7ParamsPositionMode = "CALC"
	CALCREPORT Verb7ParamsPositionMode = "CALC_REPORT"
	REPORTONLY Verb7ParamsPositionMode = "REPORT_ONLY"
)

// Defines values for Verb8ParamsFormat.
const (
	Verb8ParamsFormatJson  Verb8ParamsFormat = "json"
	Verb8ParamsFormatJsonp Verb8ParamsFormat = "jsonp"
	Verb8ParamsFormatXml   Verb8ParamsFormat = "xml"
)

// Defines values for Verb8ParamsType.
const (
	Verb8ParamsTypeA   Verb8ParamsType = "A"
	Verb8ParamsTypeALL Verb8ParamsType = "ALL"
	Verb8ParamsTypeAP  Verb8ParamsType = "AP"
	Verb8ParamsTypeP   Verb8ParamsType = "P"
	Verb8ParamsTypeS   Verb8ParamsType = "S"
	Verb8ParamsTypeSA  Verb8ParamsType = "SA"
	Verb8ParamsTypeSP  Verb8ParamsType = "SP"
)

// Defines values for Verb8ParamsLocationSelectionMode.
const (
	Verb8ParamsLocationSelectionModeSLCTA Verb8ParamsLocationSelectionMode = "SLCT_A"
	Verb8ParamsLocationSelectionModeSLCTN Verb8ParamsLocationSelectionMode = "SLCT_N"
)

// Defines values for Verb8ParamsWithEquivalentLocations.
const (
	Verb8ParamsWithEquivalentLocationsN0 Verb8ParamsWithEquivalentLocations = "0"
	Verb8ParamsWithEquivalentLocationsN1 Verb8ParamsWithEquivalentLocations = "1"
)

// Defines values for Verb8ParamsRestrictSelection.
const (
	Verb8ParamsRestrictSelectionD Verb8ParamsRestrictSelection = "D"
	Verb8ParamsRestrictSelectionI Verb8ParamsRestrictSelection = "I"
	Verb8ParamsRestrictSelectionS Verb8ParamsRestrictSelection = "S"
	Verb8ParamsRestrictSelectionV Verb8ParamsRestrictSelection = "V"
)

// Defines values for Verb8ParamsWithProducts.
const (
	Verb8ParamsWithProductsN0 Verb8ParamsWithProducts = "0"
	Verb8ParamsWithProductsN1 Verb8ParamsWithProducts = "1"
)

// Defines values for Verb8ParamsProductRepresentatives.
const (
	Verb8ParamsProductRepresentativesN0 Verb8ParamsProductRepresentatives = "0"
	Verb8ParamsProductRepresentativesN1 Verb8ParamsProductRepresentatives = "1"
)

// Defines values for Verb8ParamsFilterMode.
const (
	DISTPERI Verb8ParamsFilterMode = "DIST_PERI"
	EXCLPERI Verb8ParamsFilterMode = "EXCL_PERI"
	SLCTPERI Verb8ParamsFilterMode = "SLCT_PERI"
)

// Defines values for Verb9ParamsFormat.
const (
	Verb9ParamsFormatJson  Verb9ParamsFormat = "json"
	Verb9ParamsFormatJsonp Verb9ParamsFormat = "jsonp"
	Verb9ParamsFormatXml   Verb9ParamsFormat = "xml"
)

// Defines values for Verb9ParamsType.
const (
	Verb9ParamsTypeP   Verb9ParamsType = "P"
	Verb9ParamsTypePE  Verb9ParamsType = "PE"
	Verb9ParamsTypeS   Verb9ParamsType = "S"
	Verb9ParamsTypeSE  Verb9ParamsType = "SE"
	Verb9ParamsTypeSP  Verb9ParamsType = "SP"
	Verb9ParamsTypeSPE Verb9ParamsType = "SPE"
)

// Defines values for Verb9ParamsLocationSelectionMode.
const (
	Verb9ParamsLocationSelectionModeSLCTA Verb9ParamsLocationSelectionMode = "SLCT_A"
	Verb9ParamsLocationSelectionModeSLCTN Verb9ParamsLocationSelectionMode = "SLCT_N"
)

// Defines values for Verb10ParamsFormat.
const (
	Verb10ParamsFormatJson  Verb10ParamsFormat = "json"
	Verb10ParamsFormatJsonp Verb10ParamsFormat = "jsonp"
	Verb10ParamsFormatXml   Verb10ParamsFormat = "xml"
)

// Defines values for Verb10ParamsPoly.
const (
	Verb10ParamsPolyN0 Verb10ParamsPoly = "0"
	Verb10ParamsPolyN1 Verb10ParamsPoly = "1"
)

// Defines values for Verb10ParamsPolyEnc.
const (
	Verb10ParamsPolyEncDLT Verb10ParamsPolyEnc = "DLT"
	Verb10ParamsPolyEncGPA Verb10ParamsPolyEnc = "GPA"
	Verb10ParamsPolyEncN   Verb10ParamsPolyEnc = "N"
)

// Defines values for Verb10ParamsUseCombinedComparison.
const (
	Verb10ParamsUseCombinedComparisonN0 Verb10ParamsUseCombinedComparison = "0"
	Verb10ParamsUseCombinedComparisonN1 Verb10ParamsUseCombinedComparison = "1"
)

// Defines values for Verb10ParamsAcceptGaps.
const (
	Verb10ParamsAcceptGapsN0 Verb10ParamsAcceptGaps = "0"
	Verb10ParamsAcceptGapsN1 Verb10ParamsAcceptGaps = "1"
)

// Defines values for Verb10ParamsAllowDummySections.
const (
	Verb10ParamsAllowDummySectionsN0 Verb10ParamsAllowDummySections = "0"
	Verb10ParamsAllowDummySectionsN1 Verb10ParamsAllowDummySections = "1"
)

// Defines values for Verb10ParamsFlagAllNonReachable.
const (
	Verb10ParamsFlagAllNonReachableN0 Verb10ParamsFlagAllNonReachable = "0"
	Verb10ParamsFlagAllNonReachableN1 Verb10ParamsFlagAllNonReachable = "1"
)

// Defines values for Verb10ParamsMatchCatStrict.
const (
	Verb10ParamsMatchCatStrictN0 Verb10ParamsMatchCatStrict = "0"
	Verb10ParamsMatchCatStrictN1 Verb10ParamsMatchCatStrict = "1"
)

// Defines values for Verb10ParamsMatchIdNonBlank.
const (
	Verb10ParamsMatchIdNonBlankN0 Verb10ParamsMatchIdNonBlank = "0"
	Verb10ParamsMatchIdNonBlankN1 Verb10ParamsMatchIdNonBlank = "1"
)

// Defines values for Verb10ParamsMatchIdStrict.
const (
	Verb10ParamsMatchIdStrictN0 Verb10ParamsMatchIdStrict = "0"
	Verb10ParamsMatchIdStrictN1 Verb10ParamsMatchIdStrict = "1"
)

// Defines values for Verb10ParamsMatchNumStrict.
const (
	Verb10ParamsMatchNumStrictN0 Verb10ParamsMatchNumStrict = "0"
	Verb10ParamsMatchNumStrictN1 Verb10ParamsMatchNumStrict = "1"
)

// Defines values for Verb10ParamsMatchRtType.
const (
	Verb10ParamsMatchRtTypeN0 Verb10ParamsMatchRtType = "0"
	Verb10ParamsMatchRtTypeN1 Verb10ParamsMatchRtType = "1"
)

// Defines values for Verb10ParamsEnableRtFullSearch.
const (
	Verb10ParamsEnableRtFullSearchN0 Verb10ParamsEnableRtFullSearch = "0"
	Verb10ParamsEnableRtFullSearchN1 Verb10ParamsEnableRtFullSearch = "1"
)

// Defines values for Verb10ParamsEnableReplacements.
const (
	Verb10ParamsEnableReplacementsN0 Verb10ParamsEnableReplacements = "0"
	Verb10ParamsEnableReplacementsN1 Verb10ParamsEnableReplacements = "1"
)

// Defines values for Verb10ParamsPasslist.
const (
	Verb10ParamsPasslistN0 Verb10ParamsPasslist = "0"
	Verb10ParamsPasslistN1 Verb10ParamsPasslist = "1"
)

// Defines values for Verb10ParamsShowPassingPoints.
const (
	Verb10ParamsShowPassingPointsN0 Verb10ParamsShowPassingPoints = "0"
	Verb10ParamsShowPassingPointsN1 Verb10ParamsShowPassingPoints = "1"
)

// Defines values for Verb10ParamsRtMode.
const (
	Verb10ParamsRtModeFULL          Verb10ParamsRtMode = "FULL"
	Verb10ParamsRtModeINFOS         Verb10ParamsRtMode = "INFOS"
	Verb10ParamsRtModeOFF           Verb10ParamsRtMode = "OFF"
	Verb10ParamsRtModeREALTIME      Verb10ParamsRtMode = "REALTIME"
	Verb10ParamsRtModeSERVERDEFAULT Verb10ParamsRtMode = "SERVER_DEFAULT"
)

// Defines values for Verb10ParamsBaim.
const (
	Verb10ParamsBaimN0 Verb10ParamsBaim = "0"
	Verb10ParamsBaimN1 Verb10ParamsBaim = "1"
)

// Defines values for Verb10ParamsEco.
const (
	Verb10ParamsEcoN0 Verb10ParamsEco = "0"
	Verb10ParamsEcoN1 Verb10ParamsEco = "1"
)

// Defines values for Verb10ParamsEcoCmp.
const (
	Verb10ParamsEcoCmpN0 Verb10ParamsEcoCmp = "0"
	Verb10ParamsEcoCmpN1 Verb10ParamsEcoCmp = "1"
)

// Defines values for Verb10ParamsTariff.
const (
	Verb10ParamsTariffN0 Verb10ParamsTariff = "0"
	Verb10ParamsTariffN1 Verb10ParamsTariff = "1"
)

// Defines values for Verb10ParamsTrafficMessages.
const (
	Verb10ParamsTrafficMessagesN0 Verb10ParamsTrafficMessages = "0"
	Verb10ParamsTrafficMessagesN1 Verb10ParamsTrafficMessages = "1"
)

// Defines values for Verb10ParamsWithJourneyBoundaryPoints.
const (
	Verb10ParamsWithJourneyBoundaryPointsN0 Verb10ParamsWithJourneyBoundaryPoints = "0"
	Verb10ParamsWithJourneyBoundaryPointsN1 Verb10ParamsWithJourneyBoundaryPoints = "1"
)

// Defines values for Verb12ParamsType.
const (
	Alive Verb12ParamsType = "alive"
	Full  Verb12ParamsType = "full"
	Ready Verb12ParamsType = "ready"
)

// Defines values for Verb11ParamsFormat.
const (
	Json  Verb11ParamsFormat = "json"
	Jsonp Verb11ParamsFormat = "jsonp"
	Xml   Verb11ParamsFormat = "xml"
)

// Defines values for Verb11ParamsOriginCoordType.
const (
	Verb11ParamsOriginCoordTypeA   Verb11ParamsOriginCoordType = "A"
	Verb11ParamsOriginCoordTypeALL Verb11ParamsOriginCoordType = "ALL"
	Verb11ParamsOriginCoordTypeC   Verb11ParamsOriginCoordType = "C"
	Verb11ParamsOriginCoordTypeP   Verb11ParamsOriginCoordType = "P"
	Verb11ParamsOriginCoordTypeS   Verb11ParamsOriginCoordType = "S"
)

// Defines values for Verb11ParamsDestCoordType.
const (
	A   Verb11ParamsDestCoordType = "A"
	ALL Verb11ParamsDestCoordType = "ALL"
	C   Verb11ParamsDestCoordType = "C"
	P   Verb11ParamsDestCoordType = "P"
	S   Verb11ParamsDestCoordType = "S"
)

// Defines values for Verb11ParamsSearchForArrival.
const (
	Verb11ParamsSearchForArrivalN0 Verb11ParamsSearchForArrival = "0"
	Verb11ParamsSearchForArrivalN1 Verb11ParamsSearchForArrival = "1"
)

// Defines values for Verb11ParamsPoly.
const (
	Verb11ParamsPolyN0 Verb11ParamsPoly = "0"
	Verb11ParamsPolyN1 Verb11ParamsPoly = "1"
)

// Defines values for Verb11ParamsPolyEnc.
const (
	Verb11ParamsPolyEncDLT Verb11ParamsPolyEnc = "DLT"
	Verb11ParamsPolyEncGPA Verb11ParamsPolyEnc = "GPA"
	Verb11ParamsPolyEncN   Verb11ParamsPolyEnc = "N"
)

// Defines values for Verb11ParamsPasslist.
const (
	Verb11ParamsPasslistN0 Verb11ParamsPasslist = "0"
	Verb11ParamsPasslistN1 Verb11ParamsPasslist = "1"
)

// Defines values for Verb11ParamsIncludeIv.
const (
	Verb11ParamsIncludeIvN0 Verb11ParamsIncludeIv = "0"
	Verb11ParamsIncludeIvN1 Verb11ParamsIncludeIv = "1"
)

// Defines values for Verb11ParamsIvOnly.
const (
	Verb11ParamsIvOnlyN0 Verb11ParamsIvOnly = "0"
	Verb11ParamsIvOnlyN1 Verb11ParamsIvOnly = "1"
)

// Defines values for Verb11ParamsIncludeDrt.
const (
	Verb11ParamsIncludeDrtN0 Verb11ParamsIncludeDrt = "0"
	Verb11ParamsIncludeDrtN1 Verb11ParamsIncludeDrt = "1"
)

// Defines values for Verb11ParamsBikeCarriage.
const (
	Verb11ParamsBikeCarriageN0 Verb11ParamsBikeCarriage = "0"
	Verb11ParamsBikeCarriageN1 Verb11ParamsBikeCarriage = "1"
)

// Defines values for Verb11ParamsBikeCarriageType.
const (
	LARGEGROUPS Verb11ParamsBikeCarriageType = "LARGEGROUPS"
	SINGLEBIKES Verb11ParamsBikeCarriageType = "SINGLEBIKES"
	SMALLGROUPS Verb11ParamsBikeCarriageType = "SMALLGROUPS"
)

// Defines values for Verb11ParamsSleepingCar.
const (
	Verb11ParamsSleepingCarN0 Verb11ParamsSleepingCar = "0"
	Verb11ParamsSleepingCarN1 Verb11ParamsSleepingCar = "1"
)

// Defines values for Verb11ParamsCouchetteCoach.
const (
	Verb11ParamsCouchetteCoachN0 Verb11ParamsCouchetteCoach = "0"
	Verb11ParamsCouchetteCoachN1 Verb11ParamsCouchetteCoach = "1"
)

// Defines values for Verb11ParamsShowPassingPoints.
const (
	Verb11ParamsShowPassingPointsN0 Verb11ParamsShowPassingPoints = "0"
	Verb11ParamsShowPassingPointsN1 Verb11ParamsShowPassingPoints = "1"
)

// Defines values for Verb11ParamsBaim.
const (
	Verb11ParamsBaimN0 Verb11ParamsBaim = "0"
	Verb11ParamsBaimN1 Verb11ParamsBaim = "1"
)

// Defines values for Verb11ParamsEco.
const (
	Verb11ParamsEcoN0 Verb11ParamsEco = "0"
	Verb11ParamsEcoN1 Verb11ParamsEco = "1"
)

// Defines values for Verb11ParamsEcoCmp.
const (
	Verb11ParamsEcoCmpN0 Verb11ParamsEcoCmp = "0"
	Verb11ParamsEcoCmpN1 Verb11ParamsEcoCmp = "1"
)

// Defines values for Verb11ParamsRtMode.
const (
	FULL          Verb11ParamsRtMode = "FULL"
	INFOS         Verb11ParamsRtMode = "INFOS"
	OFF           Verb11ParamsRtMode = "OFF"
	REALTIME      Verb11ParamsRtMode = "REALTIME"
	SERVERDEFAULT Verb11ParamsRtMode = "SERVER_DEFAULT"
)

// Defines values for Verb11ParamsUnsharp.
const (
	Verb11ParamsUnsharpN0 Verb11ParamsUnsharp = "0"
	Verb11ParamsUnsharpN1 Verb11ParamsUnsharp = "1"
)

// Defines values for Verb11ParamsEconomic.
const (
	Verb11ParamsEconomicN0 Verb11ParamsEconomic = "0"
	Verb11ParamsEconomicN1 Verb11ParamsEconomic = "1"
)

// Defines values for Verb11ParamsAllowFootpathEquivalences.
const (
	Verb11ParamsAllowFootpathEquivalencesN0 Verb11ParamsAllowFootpathEquivalences = "0"
	Verb11ParamsAllowFootpathEquivalencesN1 Verb11ParamsAllowFootpathEquivalences = "1"
)

// Defines values for Verb11ParamsTrainComposition.
const (
	Verb11ParamsTrainCompositionN0 Verb11ParamsTrainComposition = "0"
	Verb11ParamsTrainCompositionN1 Verb11ParamsTrainComposition = "1"
)

// Defines values for Verb11ParamsIncludeEarlier.
const (
	Verb11ParamsIncludeEarlierN0 Verb11ParamsIncludeEarlier = "0"
	Verb11ParamsIncludeEarlierN1 Verb11ParamsIncludeEarlier = "1"
)

// Defines values for Verb11ParamsWithICTAlternatives.
const (
	Verb11ParamsWithICTAlternativesN0 Verb11ParamsWithICTAlternatives = "0"
	Verb11ParamsWithICTAlternativesN1 Verb11ParamsWithICTAlternatives = "1"
)

// Defines values for Verb11ParamsTariff.
const (
	Verb11ParamsTariffN0 Verb11ParamsTariff = "0"
	Verb11ParamsTariffN1 Verb11ParamsTariff = "1"
)

// Defines values for Verb11ParamsTrafficMessages.
const (
	Verb11ParamsTrafficMessagesN0 Verb11ParamsTrafficMessages = "0"
	Verb11ParamsTrafficMessagesN1 Verb11ParamsTrafficMessages = "1"
)

// Defines values for Verb11ParamsWithFreq.
const (
	Verb11ParamsWithFreqN0 Verb11ParamsWithFreq = "0"
	Verb11ParamsWithFreqN1 Verb11ParamsWithFreq = "1"
)

// Defines values for Verb11ParamsWithJourneyBoundaryPoints.
const (
	N0 Verb11ParamsWithJourneyBoundaryPoints = "0"
	N1 Verb11ParamsWithJourneyBoundaryPoints = "1"
)

// AffectedStopType defines model for AffectedStopType.
type AffectedStopType struct {
	StopLocation []StopLocation `json:"StopLocation"`
}

// Arrival defines model for Arrival.
type Arrival struct {
	Directions           *Directions                  `json:"Directions,omitempty"`
	JourneyDetailRef     JourneyDetailRef             `json:"JourneyDetailRef"`
	JourneyStatus        *ArrivalJourneyStatus        `json:"JourneyStatus,omitempty"`
	Messages             *Messages                    `json:"Messages,omitempty"`
	Notes                *Notes                       `json:"Notes,omitempty"`
	Occupancy            *[]OccupancyType             `json:"Occupancy,omitempty"`
	Product              *[]ProductType               `json:"Product,omitempty"`
	ProductAtStop        *ProductType                 `json:"ProductAtStop,omitempty"`
	Stops                *Stops                       `json:"Stops,omitempty"`
	Alt                  *int32                       `json:"alt,omitempty"`
	AltId                *[]string                    `json:"altId,omitempty"`
	Cancelled            *bool                        `json:"cancelled,omitempty"`
	Date                 string                       `json:"date"`
	DirectionFlag        *string                      `json:"directionFlag,omitempty"`
	Entry                *bool                        `json:"entry,omitempty"`
	HasMainMast          *bool                        `json:"hasMainMast,omitempty"`
	IsBorderStop         *bool                        `json:"isBorderStop,omitempty"`
	IsMainMast           *bool                        `json:"isMainMast,omitempty"`
	IsTurningPoint       *bool                        `json:"isTurningPoint,omitempty"`
	Lat                  *float32                     `json:"lat,omitempty"`
	Lon                  *float32                     `json:"lon,omitempty"`
	MainMast             *StopLocation                `json:"mainMast,omitempty"`
	MainMastAlt          *int32                       `json:"mainMastAlt,omitempty"`
	MainMastAltId        *[]string                    `json:"mainMastAltId,omitempty"`
	MainMastExtId        *string                      `json:"mainMastExtId,omitempty"`
	MainMastId           *string                      `json:"mainMastId,omitempty"`
	MainMastLat          *float32                     `json:"mainMastLat,omitempty"`
	MainMastLon          *float32                     `json:"mainMastLon,omitempty"`
	Name                 string                       `json:"name"`
	Origin               *string                      `json:"origin,omitempty"`
	PartCancelled        *bool                        `json:"partCancelled,omitempty"`
	Platform             *PlatformType                `json:"platform,omitempty"`
	PrognosisType        *ArrivalPrognosisType        `json:"prognosisType,omitempty"`
	Reachable            *bool                        `json:"reachable,omitempty"`
	Redirected           *bool                        `json:"redirected,omitempty"`
	ReferencedJourney    *[]ReferencedJourneyType     `json:"referencedJourney,omitempty"`
	RtCnclDataSourceType *ArrivalRtCnclDataSourceType `json:"rtCnclDataSourceType,omitempty"`
	RtDate               *string                      `json:"rtDate,omitempty"`
	RtPlatform           *PlatformType                `json:"rtPlatform,omitempty"`
	RtTime               *string                      `json:"rtTime,omitempty"`
	RtTrack              *string                      `json:"rtTrack,omitempty"`
	RtTrackHidden        *bool                        `json:"rtTrackHidden,omitempty"`
	RtTz                 *int32                       `json:"rtTz,omitempty"`
	ScheduledTimeChanged *bool                        `json:"scheduledTimeChanged,omitempty"`
	Stop                 string                       `json:"stop"`
	StopExtId            *string                      `json:"stopExtId,omitempty"`
	Stopid               string                       `json:"stopid"`
	Time                 string                       `json:"time"`
	Track                *string                      `json:"track,omitempty"`
	TrackHidden          *bool                        `json:"trackHidden,omitempty"`
	Type                 string                       `json:"type"`
	Tz                   *int32                       `json:"tz,omitempty"`
	UncertainDelay       *bool                        `json:"uncertainDelay,omitempty"`
}

// ArrivalJourneyStatus defines model for Arrival.JourneyStatus.
type ArrivalJourneyStatus string

// ArrivalPrognosisType defines model for Arrival.PrognosisType.
type ArrivalPrognosisType string

// ArrivalRtCnclDataSourceType defines model for Arrival.RtCnclDataSourceType.
type ArrivalRtCnclDataSourceType string

// ArrivalBoard defines model for ArrivalBoard.
type ArrivalBoard struct {
	Arrival              *[]Arrival         `json:"Arrival,omitempty"`
	Message              *[]Message         `json:"Message,omitempty"`
	TechnicalMessages    *TechnicalMessages `json:"TechnicalMessages,omitempty"`
	Warnings             *Warnings          `json:"Warnings,omitempty"`
	DialectVersion       *string            `json:"dialectVersion,omitempty"`
	ErrorCode            *string            `json:"errorCode,omitempty"`
	ErrorText            *string            `json:"errorText,omitempty"`
	InternalErrorCode    *string            `json:"internalErrorCode,omitempty"`
	InternalErrorText    *string            `json:"internalErrorText,omitempty"`
	InternalErrorTextOut *string            `json:"internalErrorTextOut,omitempty"`
	PlanRtTs             *time.Time         `json:"planRtTs,omitempty"`
	RequestId            *string            `json:"requestId,omitempty"`
	ServerVersion        *string            `json:"serverVersion,omitempty"`
	StopExtId            *string            `json:"stopExtId,omitempty"`
	Stopid               *string            `json:"stopid,omitempty"`
	Version              *string            `json:"version,omitempty"`
}

// CombinedProductType defines model for CombinedProductType.
type CombinedProductType struct {
	Product []ProductType `json:"Product"`
}

// ConnectionReliabilityType defines model for ConnectionReliabilityType.
type ConnectionReliabilityType struct {
	Alternative *ConnectionReliabilityTypeAlternative `json:"alternative,omitempty"`
	Original    *ConnectionReliabilityTypeOriginal    `json:"original,omitempty"`
}

// ConnectionReliabilityTypeAlternative defines model for ConnectionReliabilityType.Alternative.
type ConnectionReliabilityTypeAlternative string

// ConnectionReliabilityTypeOriginal defines model for ConnectionReliabilityType.Original.
type ConnectionReliabilityTypeOriginal string

// CoordLocation defines model for CoordLocation.
type CoordLocation struct {
	LocationNotes      *LocationNotes            `json:"LocationNotes,omitempty"`
	Alt                *int32                    `json:"alt,omitempty"`
	ChildLocation      *[]CoordLocation          `json:"childLocation,omitempty"`
	Description        *string                   `json:"description,omitempty"`
	Dist               *int32                    `json:"dist,omitempty"`
	EntryLocation      *[]CoordLocation          `json:"entryLocation,omitempty"`
	ExtId              *string                   `json:"extId,omitempty"`
	Icon               *IconType                 `json:"icon,omitempty"`
	Id                 *string                   `json:"id,omitempty"`
	Lat                *float32                  `json:"lat,omitempty"`
	Links              *[]ResourceLinks          `json:"links,omitempty"`
	Lon                *float32                  `json:"lon,omitempty"`
	MatchValue         *int32                    `json:"matchValue,omitempty"`
	McpInformation     *McpInformationType       `json:"mcpInformation,omitempty"`
	Name               string                    `json:"name"`
	Refinable          *bool                     `json:"refinable,omitempty"`
	Type               string                    `json:"type"`
	WeatherInformation *[]WeatherInformationType `json:"weatherInformation,omitempty"`
}

// Coordinate defines model for Coordinate.
type Coordinate struct {
	Alt *int32  `json:"alt,omitempty"`
	Lat float32 `json:"lat"`
	Lon float32 `json:"lon"`
}

// DataInfo defines model for DataInfo.
type DataInfo struct {
	MapInfo                     *[]MapInfoType                     `json:"MapInfo,omitempty"`
	MobilityServiceProviderInfo *[]MobilityServiceProviderInfoType `json:"MobilityServiceProviderInfo,omitempty"`
	Operator                    *[]OperatorType                    `json:"Operator,omitempty"`
	Product                     *[]ProductType                     `json:"Product,omitempty"`
	ProductCategory             *[]ProductCategoryType             `json:"ProductCategory,omitempty"`
	Region                      *[]RegionType                      `json:"Region,omitempty"`
	TechnicalMessages           *TechnicalMessages                 `json:"TechnicalMessages,omitempty"`
	Warnings                    *Warnings                          `json:"Warnings,omitempty"`
	Begin                       *string                            `json:"begin,omitempty"`
	DialectVersion              *string                            `json:"dialectVersion,omitempty"`
	End                         *string                            `json:"end,omitempty"`
	ErrorCode                   *string                            `json:"errorCode,omitempty"`
	ErrorText                   *string                            `json:"errorText,omitempty"`
	InternalErrorCode           *string                            `json:"internalErrorCode,omitempty"`
	InternalErrorText           *string                            `json:"internalErrorText,omitempty"`
	InternalErrorTextOut        *string                            `json:"internalErrorTextOut,omitempty"`
	PlanRtTs                    *time.Time                         `json:"planRtTs,omitempty"`
	RequestId                   *string                            `json:"requestId,omitempty"`
	ServerVersion               *string                            `json:"serverVersion,omitempty"`
	Version                     *string                            `json:"version,omitempty"`
}

// DateTimeIntervalType defines model for DateTimeIntervalType.
type DateTimeIntervalType struct {
	EDate *string `json:"eDate,omitempty"`
	ETime *string `json:"eTime,omitempty"`
	SDate *string `json:"sDate,omitempty"`
	STime *string `json:"sTime,omitempty"`
}

// Departure defines model for Departure.
type Departure struct {
	Directions           *Directions                    `json:"Directions,omitempty"`
	JourneyDetailRef     JourneyDetailRef               `json:"JourneyDetailRef"`
	JourneyStatus        *DepartureJourneyStatus        `json:"JourneyStatus,omitempty"`
	Messages             *Messages                      `json:"Messages,omitempty"`
	Notes                *Notes                         `json:"Notes,omitempty"`
	Occupancy            *[]OccupancyType               `json:"Occupancy,omitempty"`
	ParallelJourneyRef   *[]ParallelJourneyRefType      `json:"ParallelJourneyRef,omitempty"`
	Product              *[]ProductType                 `json:"Product,omitempty"`
	ProductAtStop        *ProductType                   `json:"ProductAtStop,omitempty"`
	Stops                *Stops                         `json:"Stops,omitempty"`
	Alt                  *int32                         `json:"alt,omitempty"`
	AltId                *[]string                      `json:"altId,omitempty"`
	Cancelled            *bool                          `json:"cancelled,omitempty"`
	Date                 string                         `json:"date"`
	DateAtArrival        *string                        `json:"dateAtArrival,omitempty"`
	Direction            *string                        `json:"direction,omitempty"`
	DirectionExtId       *string                        `json:"directionExtId,omitempty"`
	DirectionFlag        *string                        `json:"directionFlag,omitempty"`
	Entry                *bool                          `json:"entry,omitempty"`
	HasMainMast          *bool                          `json:"hasMainMast,omitempty"`
	IsBorderStop         *bool                          `json:"isBorderStop,omitempty"`
	IsFastest            *bool                          `json:"isFastest,omitempty"`
	IsMainMast           *bool                          `json:"isMainMast,omitempty"`
	IsTurningPoint       *bool                          `json:"isTurningPoint,omitempty"`
	Lat                  *float32                       `json:"lat,omitempty"`
	Lon                  *float32                       `json:"lon,omitempty"`
	MainMast             *StopLocation                  `json:"mainMast,omitempty"`
	MainMastAlt          *int32                         `json:"mainMastAlt,omitempty"`
	MainMastAltId        *[]string                      `json:"mainMastAltId,omitempty"`
	MainMastExtId        *string                        `json:"mainMastExtId,omitempty"`
	MainMastId           *string                        `json:"mainMastId,omitempty"`
	MainMastLat          *float32                       `json:"mainMastLat,omitempty"`
	MainMastLon          *float32                       `json:"mainMastLon,omitempty"`
	Name                 string                         `json:"name"`
	PartCancelled        *bool                          `json:"partCancelled,omitempty"`
	Platform             *PlatformType                  `json:"platform,omitempty"`
	PrognosisType        *DeparturePrognosisType        `json:"prognosisType,omitempty"`
	Reachable            *bool                          `json:"reachable,omitempty"`
	Redirected           *bool                          `json:"redirected,omitempty"`
	ReferencedJourney    *[]ReferencedJourneyType       `json:"referencedJourney,omitempty"`
	RtCnclDataSourceType *DepartureRtCnclDataSourceType `json:"rtCnclDataSourceType,omitempty"`
	RtDate               *string                        `json:"rtDate,omitempty"`
	RtDateAtArrival      *string                        `json:"rtDateAtArrival,omitempty"`
	RtPlatform           *PlatformType                  `json:"rtPlatform,omitempty"`
	RtTime               *string                        `json:"rtTime,omitempty"`
	RtTimeAtArrival      *string                        `json:"rtTimeAtArrival,omitempty"`
	RtTrack              *string                        `json:"rtTrack,omitempty"`
	RtTrackHidden        *bool                          `json:"rtTrackHidden,omitempty"`
	RtTz                 *int32                         `json:"rtTz,omitempty"`
	ScheduledTimeChanged *bool                          `json:"scheduledTimeChanged,omitempty"`
	Stop                 string                         `json:"stop"`
	StopExtId            *string                        `json:"stopExtId,omitempty"`
	Stopid               string                         `json:"stopid"`
	Time                 string                         `json:"time"`
	TimeAtArrival        *string                        `json:"timeAtArrival,omitempty"`
	Track                *string                        `json:"track,omitempty"`
	TrackHidden          *bool                          `json:"trackHidden,omitempty"`
	Type                 string                         `json:"type"`
	Tz                   *int32                         `json:"tz,omitempty"`
	UncertainDelay       *bool                          `json:"uncertainDelay,omitempty"`
}

// DepartureJourneyStatus defines model for Departure.JourneyStatus.
type DepartureJourneyStatus string

// DeparturePrognosisType defines model for Departure.PrognosisType.
type DeparturePrognosisType string

// DepartureRtCnclDataSourceType defines model for Departure.RtCnclDataSourceType.
type DepartureRtCnclDataSourceType string

// DepartureBoard defines model for DepartureBoard.
type DepartureBoard struct {
	Departure            *[]Departure       `json:"Departure,omitempty"`
	Message              *[]Message         `json:"Message,omitempty"`
	TechnicalMessages    *TechnicalMessages `json:"TechnicalMessages,omitempty"`
	Warnings             *Warnings          `json:"Warnings,omitempty"`
	DialectVersion       *string            `json:"dialectVersion,omitempty"`
	ErrorCode            *string            `json:"errorCode,omitempty"`
	ErrorText            *string            `json:"errorText,omitempty"`
	InternalErrorCode    *string            `json:"internalErrorCode,omitempty"`
	InternalErrorText    *string            `json:"internalErrorText,omitempty"`
	InternalErrorTextOut *string            `json:"internalErrorTextOut,omitempty"`
	PlanRtTs             *time.Time         `json:"planRtTs,omitempty"`
	RequestId            *string            `json:"requestId,omitempty"`
	ServerVersion        *string            `json:"serverVersion,omitempty"`
	StopExtId            *string            `json:"stopExtId,omitempty"`
	Stopid               *string            `json:"stopid,omitempty"`
	Version              *string            `json:"version,omitempty"`
}

// Direction defines model for Direction.
type Direction struct {
	Flag         *string `json:"flag,omitempty"`
	RouteIdxFrom *int32  `json:"routeIdxFrom,omitempty"`
	RouteIdxTo   *int32  `json:"routeIdxTo,omitempty"`
	Value        *string `json:"value,omitempty"`
}

// Directions defines model for Directions.
type Directions struct {
	Direction []Direction `json:"Direction"`
}

// EcoType defines model for EcoType.
type EcoType struct {
	Co2         *float64     `json:"co2,omitempty"`
	Co2el       *float64     `json:"co2el,omitempty"`
	Co2f        *float64     `json:"co2f,omitempty"`
	Dist        *int32       `json:"dist,omitempty"`
	Dur         *string      `json:"dur,omitempty"`
	Nmhc        *float64     `json:"nmhc,omitempty"`
	Nmvoc       *float64     `json:"nmvoc,omitempty"`
	Nox         *float64     `json:"nox,omitempty"`
	Part        *float64     `json:"part,omitempty"`
	Part10      *float64     `json:"part10,omitempty"`
	PartV       *float64     `json:"partV,omitempty"`
	Prime       *float64     `json:"prime,omitempty"`
	PrimeEnergy *float64     `json:"primeEnergy,omitempty"`
	Primef      *float64     `json:"primef,omitempty"`
	Rating      *int32       `json:"rating,omitempty"`
	So2         *float64     `json:"so2,omitempty"`
	Type        *EcoTypeType `json:"type,omitempty"`
	Ubp         *float64     `json:"ubp,omitempty"`
	Ubp13       *float64     `json:"ubp13,omitempty"`
}

// EcoTypeType defines model for EcoType.Type.
type EcoTypeType string

// ExternalContentType defines model for ExternalContentType.
type ExternalContentType struct {
	Content      *map[string]interface{} `json:"content,omitempty"`
	ContentType  *string                 `json:"contentType,omitempty"`
	Icon         *IconType               `json:"icon,omitempty"`
	Provider     *string                 `json:"provider,omitempty"`
	ProviderName *string                 `json:"providerName,omitempty"`
	Text         *string                 `json:"text,omitempty"`
}

// ExternalMessageInformationType defines model for ExternalMessageInformationType.
type ExternalMessageInformationType struct {
	ExtId    *string `json:"extId,omitempty"`
	ExtIdSrc *string `json:"extIdSrc,omitempty"`
}

// FareItem defines model for FareItem.
type FareItem struct {
	Cur             *string              `json:"cur,omitempty"`
	Desc            *string              `json:"desc,omitempty"`
	ExternalContent *ExternalContentType `json:"externalContent,omitempty"`
	FromLeg         *int32               `json:"fromLeg,omitempty"`
	FromLegId       *string              `json:"fromLegId,omitempty"`
	Name            *string              `json:"name,omitempty"`
	Param           *[]KVType            `json:"param,omitempty"`
	Price           *int32               `json:"price,omitempty"`
	ShpCtx          *string              `json:"shpCtx,omitempty"`
	Ticket          *[]Ticket            `json:"ticket,omitempty"`
	ToLeg           *int32               `json:"toLeg,omitempty"`
	ToLegId         *string              `json:"toLegId,omitempty"`
}

// FareSetItem defines model for FareSetItem.
type FareSetItem struct {
	Desc      *string     `json:"desc,omitempty"`
	FareItem  *[]FareItem `json:"fareItem,omitempty"`
	FromLeg   *int32      `json:"fromLeg,omitempty"`
	FromLegId *string     `json:"fromLegId,omitempty"`
	Name      *string     `json:"name,omitempty"`
	Param     *[]KVType   `json:"param,omitempty"`
	ToLeg     *int32      `json:"toLeg,omitempty"`
	ToLegId   *string     `json:"toLegId,omitempty"`
}

// FreqType defines model for FreqType.
type FreqType struct {
	AlternativeCount *int32         `json:"alternativeCount,omitempty"`
	Journey          *[]JourneyType `json:"journey,omitempty"`
	WaitMaximum      *int32         `json:"waitMaximum,omitempty"`
	WaitMinimum      *int32         `json:"waitMinimum,omitempty"`
}

// GisEdgeType defines model for GisEdgeType.
type GisEdgeType struct {
	EdgeId  *string `json:"edgeId,omitempty"`
	GraphId *string `json:"graphId,omitempty"`
}

// GisRef defines model for GisRef.
type GisRef struct {
	Ref string `json:"ref"`
}

// GisRouteSegment defines model for GisRouteSegment.
type GisRouteSegment struct {
	Edge           *[]GisEdgeType        `json:"Edge,omitempty"`
	Messages       *Messages             `json:"Messages,omitempty"`
	Notes          *Notes                `json:"Notes,omitempty"`
	TrafficMessage *[]TrafficMessageType `json:"TrafficMessage,omitempty"`
	DirTx          *string               `json:"dirTx,omitempty"`
	Dist           *int32                `json:"dist,omitempty"`
	DurS           *string               `json:"durS,omitempty"`
	Man            *GisRouteSegmentMan   `json:"man,omitempty"`
	ManTargetName  *string               `json:"manTargetName,omitempty"`
	ManTx          *string               `json:"manTx,omitempty"`
	Name           *string               `json:"name,omitempty"`
	Ori            *GisRouteSegmentOri   `json:"ori,omitempty"`
	PolyE          *int32                `json:"polyE,omitempty"`
	PolyS          *int32                `json:"polyS,omitempty"`
	RNum           *string               `json:"rNum,omitempty"`
	RType          *GisRouteSegmentRType `json:"rType,omitempty"`
}

// GisRouteSegmentMan defines model for GisRouteSegment.Man.
type GisRouteSegmentMan string

// GisRouteSegmentOri defines model for GisRouteSegment.Ori.
type GisRouteSegmentOri string

// GisRouteSegmentRType defines model for GisRouteSegment.RType.
type GisRouteSegmentRType string

// GisRouteType defines model for GisRouteType.
type GisRouteType struct {
	Notes            *Notes             `json:"Notes,omitempty"`
	AltPolyline      *[]Polyline        `json:"altPolyline,omitempty"`
	AltPolylineGroup *[]PolylineGroup   `json:"altPolylineGroup,omitempty"`
	DirGeo           *int32             `json:"dirGeo,omitempty"`
	DirTxt           *string            `json:"dirTxt,omitempty"`
	Dist             *int32             `json:"dist,omitempty"`
	DurR             *string            `json:"durR,omitempty"`
	DurS             *string            `json:"durS,omitempty"`
	DurST            *string            `json:"durST,omitempty"`
	DurW2C           *string            `json:"durW2C,omitempty"`
	DurW2D           *string            `json:"durW2D,omitempty"`
	EdgeHashR        *string            `json:"edgeHashR,omitempty"`
	EdgeHashS        *string            `json:"edgeHashS,omitempty"`
	Polyline         *Polyline          `json:"polyline,omitempty"`
	PolylineGroup    *PolylineGroup     `json:"polylineGroup,omitempty"`
	Seg              *[]GisRouteSegment `json:"seg,omitempty"`
	TotDownhill      *float64           `json:"totDownhill,omitempty"`
	TotUphill        *float64           `json:"totUphill,omitempty"`
}

// HimMessages defines model for HimMessages.
type HimMessages struct {
	Message              *[]Message         `json:"Message,omitempty"`
	TechnicalMessages    *TechnicalMessages `json:"TechnicalMessages,omitempty"`
	Warnings             *Warnings          `json:"Warnings,omitempty"`
	DialectVersion       *string            `json:"dialectVersion,omitempty"`
	ErrorCode            *string            `json:"errorCode,omitempty"`
	ErrorText            *string            `json:"errorText,omitempty"`
	InternalErrorCode    *string            `json:"internalErrorCode,omitempty"`
	InternalErrorText    *string            `json:"internalErrorText,omitempty"`
	InternalErrorTextOut *string            `json:"internalErrorTextOut,omitempty"`
	PlanRtTs             *time.Time         `json:"planRtTs,omitempty"`
	RequestId            *string            `json:"requestId,omitempty"`
	ServerVersion        *string            `json:"serverVersion,omitempty"`
	Version              *string            `json:"version,omitempty"`
}

// IconType defines model for IconType.
type IconType struct {
	BackgroundColor *RGBAColorType `json:"backgroundColor,omitempty"`
	BorderColor     *RGBAColorType `json:"borderColor,omitempty"`
	ForegroundColor *RGBAColorType `json:"foregroundColor,omitempty"`
	Res             *string        `json:"res,omitempty"`
	Shape           *IconTypeShape `json:"shape,omitempty"`
	ShapeRes        *string        `json:"shapeRes,omitempty"`
	Style           *IconTypeStyle `json:"style,omitempty"`
	Txt             *string        `json:"txt,omitempty"`
	TxtS            *string        `json:"txtS,omitempty"`
}

// IconTypeShape defines model for IconType.Shape.
type IconTypeShape string

// IconTypeStyle defines model for IconType.Style.
type IconTypeStyle string

// JourneyDetail defines model for JourneyDetail.
type JourneyDetail struct {
	Directions              *Directions                           `json:"Directions,omitempty"`
	JourneyStatus           *JourneyDetailJourneyStatus           `json:"JourneyStatus,omitempty"`
	Messages                *Messages                             `json:"Messages,omitempty"`
	Names                   *Names                                `json:"Names,omitempty"`
	Notes                   *Notes                                `json:"Notes,omitempty"`
	ParallelJourneyRef      *[]ParallelJourneyRefType             `json:"ParallelJourneyRef,omitempty"`
	Polyline                *Polyline                             `json:"Polyline,omitempty"`
	PolylineGroup           *PolylineGroup                        `json:"PolylineGroup,omitempty"`
	Product                 *[]ProductType                        `json:"Product,omitempty"`
	ServiceDays             *[]ServiceDays                        `json:"ServiceDays,omitempty"`
	Stops                   Stops                                 `json:"Stops"`
	TechnicalMessages       *TechnicalMessages                    `json:"TechnicalMessages,omitempty"`
	Warnings                *Warnings                             `json:"Warnings,omitempty"`
	Cancelled               *bool                                 `json:"cancelled,omitempty"`
	DayOfOperation          string                                `json:"dayOfOperation"`
	DialectVersion          *string                               `json:"dialectVersion,omitempty"`
	ErrorCode               *string                               `json:"errorCode,omitempty"`
	ErrorText               *string                               `json:"errorText,omitempty"`
	InternalErrorCode       *string                               `json:"internalErrorCode,omitempty"`
	InternalErrorText       *string                               `json:"internalErrorText,omitempty"`
	InternalErrorTextOut    *string                               `json:"internalErrorTextOut,omitempty"`
	LastPassRouteIdx        *int32                                `json:"lastPassRouteIdx,omitempty"`
	LastPassStopRef         *int32                                `json:"lastPassStopRef,omitempty"`
	LastPos                 *Coordinate                           `json:"lastPos,omitempty"`
	LastPosReported         *time.Time                            `json:"lastPosReported,omitempty"`
	ParallelJourneyLinkType *JourneyDetailParallelJourneyLinkType `json:"parallelJourneyLinkType,omitempty"`
	PartCancelled           *bool                                 `json:"partCancelled,omitempty"`
	PlanRtTs                *time.Time                            `json:"planRtTs,omitempty"`
	Reachable               *bool                                 `json:"reachable,omitempty"`
	Redirected              *bool                                 `json:"redirected,omitempty"`
	Ref                     string                                `json:"ref"`
	ReferencedJourney       *[]ReferencedJourneyType              `json:"referencedJourney,omitempty"`
	RequestId               *string                               `json:"requestId,omitempty"`
	RtLastPassRouteIdx      *int32                                `json:"rtLastPassRouteIdx,omitempty"`
	RtLastPassStopRef       *int32                                `json:"rtLastPassStopRef,omitempty"`
	ServerVersion           *string                               `json:"serverVersion,omitempty"`
	UncertainDelay          *bool                                 `json:"uncertainDelay,omitempty"`
	Version                 *string                               `json:"version,omitempty"`
}

// JourneyDetailJourneyStatus defines model for JourneyDetail.JourneyStatus.
type JourneyDetailJourneyStatus string

// JourneyDetailParallelJourneyLinkType defines model for JourneyDetail.ParallelJourneyLinkType.
type JourneyDetailParallelJourneyLinkType string

// JourneyDetailRef defines model for JourneyDetailRef.
type JourneyDetailRef struct {
	Ref string `json:"ref"`
}

// JourneyList defines model for JourneyList.
type JourneyList struct {
	Journey              *[]JourneyType     `json:"Journey,omitempty"`
	TechnicalMessages    *TechnicalMessages `json:"TechnicalMessages,omitempty"`
	Warnings             *Warnings          `json:"Warnings,omitempty"`
	DialectVersion       *string            `json:"dialectVersion,omitempty"`
	ErrorCode            *string            `json:"errorCode,omitempty"`
	ErrorText            *string            `json:"errorText,omitempty"`
	InternalErrorCode    *string            `json:"internalErrorCode,omitempty"`
	InternalErrorText    *string            `json:"internalErrorText,omitempty"`
	InternalErrorTextOut *string            `json:"internalErrorTextOut,omitempty"`
	PlanRtTs             *time.Time         `json:"planRtTs,omitempty"`
	PlanningPeriodBegin  *string            `json:"planningPeriodBegin,omitempty"`
	PlanningPeriodEnd    *string            `json:"planningPeriodEnd,omitempty"`
	RequestId            *string            `json:"requestId,omitempty"`
	ServerVersion        *string            `json:"serverVersion,omitempty"`
	Version              *string            `json:"version,omitempty"`
}

// JourneyPathItemType defines model for JourneyPathItemType.
type JourneyPathItemType struct {
	DirGeo            *int32                    `json:"dirGeo,omitempty"`
	FromLocationId    *string                   `json:"fromLocationId,omitempty"`
	ProgressAbs       *int32                    `json:"progressAbs,omitempty"`
	ProgressInPercent *int32                    `json:"progressInPercent,omitempty"`
	ProgressInTime    *int32                    `json:"progressInTime,omitempty"`
	State             *JourneyPathItemTypeState `json:"state,omitempty"`
	ToLocationId      *string                   `json:"toLocationId,omitempty"`
}

// JourneyPathItemTypeState defines model for JourneyPathItemType.State.
type JourneyPathItemTypeState string

// JourneyPathType defines model for JourneyPathType.
type JourneyPathType struct {
	JourneyPathItem []JourneyPathItemType `json:"JourneyPathItem"`
	Location        *[]StopType           `json:"Location,omitempty"`
	PolylineGroup   *PolylineGroup        `json:"PolylineGroup,omitempty"`
}

// JourneyType defines model for JourneyType.
type JourneyType struct {
	JourneyDestination      *OriginDestType                     `json:"JourneyDestination,omitempty"`
	JourneyDetailRef        *JourneyDetailRef                   `json:"JourneyDetailRef,omitempty"`
	JourneyOrigin           *OriginDestType                     `json:"JourneyOrigin,omitempty"`
	JourneyPath             *JourneyPathType                    `json:"JourneyPath,omitempty"`
	Messages                *Messages                           `json:"Messages,omitempty"`
	Notes                   *Notes                              `json:"Notes,omitempty"`
	Occupancy               *[]OccupancyType                    `json:"Occupancy,omitempty"`
	ParallelJourneyRef      *[]ParallelJourneyRefType           `json:"ParallelJourneyRef,omitempty"`
	Product                 *ProductType                        `json:"Product,omitempty"`
	Stops                   *Stops                              `json:"Stops,omitempty"`
	AddName                 *string                             `json:"addName,omitempty"`
	Alt                     *int32                              `json:"alt,omitempty"`
	Direction               *string                             `json:"direction,omitempty"`
	DirectionFlag           *string                             `json:"directionFlag,omitempty"`
	Lat                     *float32                            `json:"lat,omitempty"`
	Lon                     *float32                            `json:"lon,omitempty"`
	Name                    string                              `json:"name"`
	ParallelJourneyLinkType *JourneyTypeParallelJourneyLinkType `json:"parallelJourneyLinkType,omitempty"`
	ReferencedJourney       *[]ReferencedJourneyType            `json:"referencedJourney,omitempty"`
	TrainCategory           *string                             `json:"trainCategory,omitempty"`
	TrainNumber             *string                             `json:"trainNumber,omitempty"`
}

// JourneyTypeParallelJourneyLinkType defines model for JourneyType.ParallelJourneyLinkType.
type JourneyTypeParallelJourneyLinkType string

// KVType defines model for KVType.
type KVType struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// Leg defines model for Leg.
type Leg struct {
	CombinedProduct       *[]CombinedProductType    `json:"CombinedProduct,omitempty"`
	Destination           OriginDestType            `json:"Destination"`
	Eco                   *EcoType                  `json:"Eco,omitempty"`
	Freq                  *FreqType                 `json:"Freq,omitempty"`
	GisRef                *GisRef                   `json:"GisRef,omitempty"`
	GisRoute              *GisRouteType             `json:"GisRoute,omitempty"`
	JourneyDestination    *OriginDestType           `json:"JourneyDestination,omitempty"`
	JourneyDetail         *JourneyDetail            `json:"JourneyDetail,omitempty"`
	JourneyDetailRef      *JourneyDetailRef         `json:"JourneyDetailRef,omitempty"`
	JourneyOrigin         *OriginDestType           `json:"JourneyOrigin,omitempty"`
	JourneyStatus         *LegJourneyStatus         `json:"JourneyStatus,omitempty"`
	Messages              *Messages                 `json:"Messages,omitempty"`
	Notes                 *Notes                    `json:"Notes,omitempty"`
	Occupancy             *[]OccupancyType          `json:"Occupancy,omitempty"`
	Origin                OriginDestType            `json:"Origin"`
	ParallelJourney       *[]JourneyType            `json:"ParallelJourney,omitempty"`
	ParallelJourneyRef    *[]ParallelJourneyRefType `json:"ParallelJourneyRef,omitempty"`
	Polyline              *Polyline                 `json:"Polyline,omitempty"`
	PolylineGroup         *PolylineGroup            `json:"PolylineGroup,omitempty"`
	Product               *[]ProductType            `json:"Product,omitempty"`
	ServiceDays           *[]ServiceDays            `json:"ServiceDays,omitempty"`
	Stops                 *Stops                    `json:"Stops,omitempty"`
	TrafficMessage        *[]TrafficMessageType     `json:"TrafficMessage,omitempty"`
	AddName               *string                   `json:"addName,omitempty"`
	Cancelled             *bool                     `json:"cancelled,omitempty"`
	Category              *string                   `json:"category,omitempty"`
	ChangeAssured         *bool                     `json:"changeAssured,omitempty"`
	ChangeRequired        *bool                     `json:"changeRequired,omitempty"`
	Direction             *string                   `json:"direction,omitempty"`
	DirectionFlag         *string                   `json:"directionFlag,omitempty"`
	Dist                  *int32                    `json:"dist,omitempty"`
	Duration              *string                   `json:"duration,omitempty"`
	Hide                  *bool                     `json:"hide,omitempty"`
	Id                    string                    `json:"id"`
	Idx                   int32                     `json:"idx"`
	MinimumChangeDuration *string                   `json:"minimumChangeDuration,omitempty"`
	Name                  *string                   `json:"name,omitempty"`
	Number                *string                   `json:"number,omitempty"`
	PartCancelled         *bool                     `json:"partCancelled,omitempty"`
	PsCtxArriveEarlier    *string                   `json:"psCtxArriveEarlier,omitempty"`
	PsCtxDepartLater      *string                   `json:"psCtxDepartLater,omitempty"`
	Reachable             *bool                     `json:"reachable,omitempty"`
	RecState              *LegRecState              `json:"recState,omitempty"`
	Redirected            *bool                     `json:"redirected,omitempty"`
	ReferencedJourney     *[]ReferencedJourneyType  `json:"referencedJourney,omitempty"`
	Type                  string                    `json:"type"`
	UncertainDelay        *bool                     `json:"uncertainDelay,omitempty"`
	Waiting               *bool                     `json:"waiting,omitempty"`
	WaitingState          *LegWaitingState          `json:"waitingState,omitempty"`
}

// LegJourneyStatus defines model for Leg.JourneyStatus.
type LegJourneyStatus string

// LegRecState defines model for Leg.RecState.
type LegRecState string

// LegWaitingState defines model for Leg.WaitingState.
type LegWaitingState string

// LegList defines model for LegList.
type LegList struct {
	Leg *[]Leg `json:"Leg,omitempty"`
}

// Location defines model for Location.
type Location struct {
	Note  *[]LocationNote `json:"Note,omitempty"`
	Alt   *int32          `json:"alt,omitempty"`
	ExtId *string         `json:"extId,omitempty"`
	Id    *string         `json:"id,omitempty"`
	Lat   *float32        `json:"lat,omitempty"`
	Lon   *float32        `json:"lon,omitempty"`
	Name  *string         `json:"name,omitempty"`
	Type  *string         `json:"type,omitempty"`
}

// LocationList defines model for LocationList.
type LocationList struct {
	TechnicalMessages           *TechnicalMessages                               `json:"TechnicalMessages,omitempty"`
	Warnings                    *Warnings                                        `json:"Warnings,omitempty"`
	DialectVersion              *string                                          `json:"dialectVersion,omitempty"`
	ErrorCode                   *string                                          `json:"errorCode,omitempty"`
	ErrorText                   *string                                          `json:"errorText,omitempty"`
	InternalErrorCode           *string                                          `json:"internalErrorCode,omitempty"`
	InternalErrorText           *string                                          `json:"internalErrorText,omitempty"`
	InternalErrorTextOut        *string                                          `json:"internalErrorTextOut,omitempty"`
	PlanRtTs                    *time.Time                                       `json:"planRtTs,omitempty"`
	RequestId                   *string                                          `json:"requestId,omitempty"`
	ScrollCtx                   *[]string                                        `json:"scrollCtx,omitempty"`
	ServerVersion               *string                                          `json:"serverVersion,omitempty"`
	StopLocationOrCoordLocation *[]LocationList_StopLocationOrCoordLocation_Item `json:"stopLocationOrCoordLocation,omitempty"`
	Version                     *string                                          `json:"version,omitempty"`
}

// LocationList_StopLocationOrCoordLocation_Item defines model for LocationList.stopLocationOrCoordLocation.Item.
type LocationList_StopLocationOrCoordLocation_Item struct {
	union json.RawMessage
}

// LocationNote defines model for LocationNote.
type LocationNote struct {
	Key           *string           `json:"key,omitempty"`
	RtActivated   *bool             `json:"rtActivated,omitempty"`
	RtDeactivated *bool             `json:"rtDeactivated,omitempty"`
	TxtL          *string           `json:"txtL,omitempty"`
	TxtN          *string           `json:"txtN,omitempty"`
	TxtS          *string           `json:"txtS,omitempty"`
	Type          *LocationNoteType `json:"type,omitempty"`
	Url           *string           `json:"url,omitempty"`
	Value         *string           `json:"value,omitempty"`
}

// LocationNoteType defines model for LocationNote.Type.
type LocationNoteType string

// LocationNotes defines model for LocationNotes.
type LocationNotes struct {
	LocationNote []LocationNote `json:"LocationNote"`
}

// MapInfoType defines model for MapInfoType.
type MapInfoType struct {
	BaseMap    *[]MapLayerType `json:"BaseMap,omitempty"`
	OverlayMap *[]MapLayerType `json:"OverlayMap,omitempty"`
}

// MapLayerType defines model for MapLayerType.
type MapLayerType struct {
	Attribute          *string   `json:"attribute,omitempty"`
	Extend             *Rect     `json:"extend,omitempty"`
	Id                 string    `json:"id"`
	InitialBoundingBox *Rect     `json:"initialBoundingBox,omitempty"`
	Label              *string   `json:"label,omitempty"`
	Opacity            *int32    `json:"opacity,omitempty"`
	Projection         *string   `json:"projection,omitempty"`
	Selectable         *bool     `json:"selectable,omitempty"`
	Show               *bool     `json:"show,omitempty"`
	Subdomain          *[]string `json:"subdomain,omitempty"`
	Type               *string   `json:"type,omitempty"`
	Url                *string   `json:"url,omitempty"`
	ZoomMax            *int32    `json:"zoomMax,omitempty"`
	ZoomMin            *int32    `json:"zoomMin,omitempty"`
}

// McpAvailabilityType defines model for McpAvailabilityType.
type McpAvailabilityType struct {
	EndBoundaryType    *McpAvailabilityTypeEndBoundaryType    `json:"endBoundaryType,omitempty"`
	IntervalLimitation *McpAvailabilityTypeIntervalLimitation `json:"intervalLimitation,omitempty"`
	StartBoundaryType  *McpAvailabilityTypeStartBoundaryType  `json:"startBoundaryType,omitempty"`
	TimeInterval       *DateTimeIntervalType                  `json:"timeInterval,omitempty"`
}

// McpAvailabilityTypeEndBoundaryType defines model for McpAvailabilityType.EndBoundaryType.
type McpAvailabilityTypeEndBoundaryType string

// McpAvailabilityTypeIntervalLimitation defines model for McpAvailabilityType.IntervalLimitation.
type McpAvailabilityTypeIntervalLimitation string

// McpAvailabilityTypeStartBoundaryType defines model for McpAvailabilityType.StartBoundaryType.
type McpAvailabilityTypeStartBoundaryType string

// McpInformationType defines model for McpInformationType.
type McpInformationType struct {
	Availabilities     *[]McpAvailabilityType                `json:"availabilities,omitempty"`
	Details            *string                               `json:"details,omitempty"`
	ExternalContent    *ExternalContentType                  `json:"externalContent,omitempty"`
	ExternalId         *string                               `json:"externalId,omitempty"`
	Id                 *string                               `json:"id,omitempty"`
	LastUpdateDate     string                                `json:"lastUpdateDate"`
	LastUpdateTime     string                                `json:"lastUpdateTime"`
	Modalities         *[]McpModalityType                    `json:"modalities,omitempty"`
	Occupancy          *McpInformationTypeOccupancy          `json:"occupancy,omitempty"`
	PhysicalAccessType *McpInformationTypePhysicalAccessType `json:"physicalAccessType,omitempty"`
	Provider           *string                               `json:"provider,omitempty"`
	ProviderName       *string                               `json:"providerName,omitempty"`
	Type               *McpInformationTypeType               `json:"type,omitempty"`
}

// McpInformationTypeOccupancy defines model for McpInformationType.Occupancy.
type McpInformationTypeOccupancy string

// McpInformationTypePhysicalAccessType defines model for McpInformationType.PhysicalAccessType.
type McpInformationTypePhysicalAccessType string

// McpInformationTypeType defines model for McpInformationType.Type.
type McpInformationTypeType string

// McpModalityType defines model for McpModalityType.
type McpModalityType struct {
	PlaceType     *McpModalityTypePlaceType     `json:"placeType,omitempty"`
	TransportMode *McpModalityTypeTransportMode `json:"transportMode,omitempty"`
	UsageType     *McpModalityTypeUsageType     `json:"usageType,omitempty"`
}

// McpModalityTypePlaceType defines model for McpModalityType.PlaceType.
type McpModalityTypePlaceType string

// McpModalityTypeTransportMode defines model for McpModalityType.TransportMode.
type McpModalityTypeTransportMode string

// McpModalityTypeUsageType defines model for McpModalityType.UsageType.
type McpModalityTypeUsageType string

// Message defines model for Message.
type Message struct {
	Note            *[]Note                         `json:"Note,omitempty"`
	Act             *bool                           `json:"act,omitempty"`
	AffectedJourney *[]JourneyType                  `json:"affectedJourney,omitempty"`
	AffectedProduct *[]ProductType                  `json:"affectedProduct,omitempty"`
	AffectedStops   *AffectedStopType               `json:"affectedStops,omitempty"`
	AltEnd          *string                         `json:"altEnd,omitempty"`
	AltSection      *string                         `json:"altSection,omitempty"`
	AltStart        *string                         `json:"altStart,omitempty"`
	BaseType        *MessageBaseType                `json:"baseType,omitempty"`
	Category        *string                         `json:"category,omitempty"`
	Channel         *[]MessageChannelType           `json:"channel,omitempty"`
	Company         *string                         `json:"company,omitempty"`
	CustomText      *string                         `json:"customText,omitempty"`
	DailyDuration   *string                         `json:"dailyDuration,omitempty"`
	DailyStartingAt *string                         `json:"dailyStartingAt,omitempty"`
	EDate           *string                         `json:"eDate,omitempty"`
	ETime           *string                         `json:"eTime,omitempty"`
	Edge            *[]MessageEdgeType              `json:"edge,omitempty"`
	Event           *[]MessageEventType             `json:"event,omitempty"`
	ExtInfo         *ExternalMessageInformationType `json:"extInfo,omitempty"`
	ExternalId      *string                         `json:"externalId,omitempty"`
	Head            *string                         `json:"head,omitempty"`
	Icon            *string                         `json:"icon,omitempty"`
	Id              string                          `json:"id"`
	Lead            *string                         `json:"lead,omitempty"`
	Message         *[]Message                      `json:"message,omitempty"`
	MessageCategory *[]MessageCategoryType          `json:"messageCategory,omitempty"`
	MessageText     *[]MessageTextType              `json:"messageText,omitempty"`
	ModDate         *string                         `json:"modDate,omitempty"`
	ModTime         *string                         `json:"modTime,omitempty"`
	Priority        *int32                          `json:"priority,omitempty"`
	Products        *int32                          `json:"products,omitempty"`
	Region          *[]MessageRegionType            `json:"region,omitempty"`
	RouteIdxFrom    *int32                          `json:"routeIdxFrom,omitempty"`
	RouteIdxTo      *int32                          `json:"routeIdxTo,omitempty"`
	SDate           *string                         `json:"sDate,omitempty"`
	STime           *string                         `json:"sTime,omitempty"`
	Tags            *TagsType                       `json:"tags,omitempty"`
	Tckr            *string                         `json:"tckr,omitempty"`
	Text            *string                         `json:"text,omitempty"`
	TextInternal    *string                         `json:"textInternal,omitempty"`
	ValidFromStop   *StopType                       `json:"validFromStop,omitempty"`
	ValidToStop     *StopType                       `json:"validToStop,omitempty"`
	ValidityDays    *ServiceDays                    `json:"validityDays,omitempty"`
}

// MessageBaseType defines model for Message.BaseType.
type MessageBaseType string

// MessageCategoryType defines model for MessageCategoryType.
type MessageCategoryType struct {
	Id   int32   `json:"id"`
	Name *string `json:"name,omitempty"`
}

// MessageChannelType defines model for MessageChannelType.
type MessageChannelType struct {
	Name          *string        `json:"name,omitempty"`
	Url           *[]UrlLinkType `json:"url,omitempty"`
	ValidFromDate *string        `json:"validFromDate,omitempty"`
	ValidFromTime *string        `json:"validFromTime,omitempty"`
	ValidToDate   *string        `json:"validToDate,omitempty"`
	ValidToTime   *string        `json:"validToTime,omitempty"`
}

// MessageEdgeType defines model for MessageEdgeType.
type MessageEdgeType struct {
	Direction      *int32         `json:"direction,omitempty"`
	EStop          *StopType      `json:"eStop,omitempty"`
	Estop          *StopType      `json:"estop,omitempty"`
	IconCoordinate *Coordinate    `json:"iconCoordinate,omitempty"`
	MessageRef     *[]int32       `json:"messageRef,omitempty"`
	Polyline       *[]Polyline    `json:"polyline,omitempty"`
	PolylineGroup  *PolylineGroup `json:"polylineGroup,omitempty"`
	SStop          *StopType      `json:"sStop,omitempty"`
	Sstop          *StopType      `json:"sstop,omitempty"`
}

// MessageEventType defines model for MessageEventType.
type MessageEventType struct {
	Current      *bool        `json:"current,omitempty"`
	Direction    *int32       `json:"direction,omitempty"`
	EDaily       *string      `json:"eDaily,omitempty"`
	EDate        *string      `json:"eDate,omitempty"`
	EStop        *StopType    `json:"eStop,omitempty"`
	ETime        *string      `json:"eTime,omitempty"`
	Estop        *StopType    `json:"estop,omitempty"`
	SDaily       *string      `json:"sDaily,omitempty"`
	SDate        *string      `json:"sDate,omitempty"`
	SStop        *StopType    `json:"sStop,omitempty"`
	STime        *string      `json:"sTime,omitempty"`
	SectionNum   *[]string    `json:"sectionNum,omitempty"`
	Sstop        *StopType    `json:"sstop,omitempty"`
	ValidityDays *ServiceDays `json:"validityDays,omitempty"`
}

// MessageRegionType defines model for MessageRegionType.
type MessageRegionType struct {
	IconCoordinate *Coordinate    `json:"iconCoordinate,omitempty"`
	Id             *string        `json:"id,omitempty"`
	MessageRef     *[]int32       `json:"messageRef,omitempty"`
	Name           *string        `json:"name,omitempty"`
	Polyline       *[]Polyline    `json:"polyline,omitempty"`
	PolylineGroup  *PolylineGroup `json:"polylineGroup,omitempty"`
	Ring           *Ring          `json:"ring,omitempty"`
}

// MessageTextType defines model for MessageTextType.
type MessageTextType struct {
	Tag  []string `json:"tag"`
	Text []string `json:"text"`
}

// Messages defines model for Messages.
type Messages struct {
	Message []Message `json:"Message"`
}

// MobilityServiceProviderInfoType defines model for MobilityServiceProviderInfoType.
type MobilityServiceProviderInfoType struct {
	Abbreviation *string `json:"abbreviation,omitempty"`
	ExtId        *string `json:"extId,omitempty"`
	Id           *string `json:"id,omitempty"`
	Name         *string `json:"name,omitempty"`
	NameS        *string `json:"nameS,omitempty"`
}

// Name defines model for Name.
type Name struct {
	Product      *ProductType `json:"Product,omitempty"`
	AddName      *string      `json:"addName,omitempty"`
	Category     *string      `json:"category,omitempty"`
	Name         string       `json:"name"`
	Number       string       `json:"number"`
	RouteIdxFrom *int32       `json:"routeIdxFrom,omitempty"`
	RouteIdxTo   *int32       `json:"routeIdxTo,omitempty"`
}

// Names defines model for Names.
type Names struct {
	Name []Name `json:"Name"`
}

// Note defines model for Note.
type Note struct {
	Key           *string   `json:"key,omitempty"`
	Priority      *int32    `json:"priority,omitempty"`
	RouteIdxFrom  *int32    `json:"routeIdxFrom,omitempty"`
	RouteIdxTo    *int32    `json:"routeIdxTo,omitempty"`
	RtActivated   *bool     `json:"rtActivated,omitempty"`
	RtDeactivated *bool     `json:"rtDeactivated,omitempty"`
	TxtL          *string   `json:"txtL,omitempty"`
	TxtN          *string   `json:"txtN,omitempty"`
	TxtS          *string   `json:"txtS,omitempty"`
	Type          *NoteType `json:"type,omitempty"`
	Url           *string   `json:"url,omitempty"`
	Value         *string   `json:"value,omitempty"`
}

// NoteType defines model for Note.Type.
type NoteType string

// Notes defines model for Notes.
type Notes struct {
	Note []Note `json:"Note"`
}

// OccupancyType defines model for OccupancyType.
type OccupancyType struct {
	Name   *string `json:"name,omitempty"`
	Number *string `json:"number,omitempty"`
	Raw    *int32  `json:"raw,omitempty"`
	V      *int32  `json:"v,omitempty"`
}

// OperatorType defines model for OperatorType.
type OperatorType struct {
	AddName        *string   `json:"addName,omitempty"`
	Administration *[]string `json:"administration,omitempty"`
	Id             *string   `json:"id,omitempty"`
	Name           string    `json:"name"`
	NameL          *string   `json:"nameL,omitempty"`
	NameN          *string   `json:"nameN,omitempty"`
	NameS          *string   `json:"nameS,omitempty"`
	Url            *string   `json:"url,omitempty"`
}

// OriginDestType defines model for OriginDestType.
type OriginDestType struct {
	Notes                  *Notes                              `json:"Notes,omitempty"`
	Occupancy              *[]OccupancyType                    `json:"Occupancy,omitempty"`
	Additional             *bool                               `json:"additional,omitempty"`
	Alighting              *bool                               `json:"alighting,omitempty"`
	Alt                    *int32                              `json:"alt,omitempty"`
	AltId                  *[]string                           `json:"altId,omitempty"`
	Boarding               *bool                               `json:"boarding,omitempty"`
	Cancelled              *bool                               `json:"cancelled,omitempty"`
	CancelledArrival       *bool                               `json:"cancelledArrival,omitempty"`
	CancelledDeparture     *bool                               `json:"cancelledDeparture,omitempty"`
	Date                   string                              `json:"date"`
	Description            *string                             `json:"description,omitempty"`
	Entry                  *bool                               `json:"entry,omitempty"`
	ExtId                  *string                             `json:"extId,omitempty"`
	HasMainMast            *bool                               `json:"hasMainMast,omitempty"`
	Hide                   *bool                               `json:"hide,omitempty"`
	Id                     *string                             `json:"id,omitempty"`
	IsBorderStop           *bool                               `json:"isBorderStop,omitempty"`
	IsMainMast             *bool                               `json:"isMainMast,omitempty"`
	IsTurningPoint         *bool                               `json:"isTurningPoint,omitempty"`
	Lat                    *float32                            `json:"lat,omitempty"`
	Lon                    *float32                            `json:"lon,omitempty"`
	MainMast               *StopLocation                       `json:"mainMast,omitempty"`
	MainMastAlt            *int32                              `json:"mainMastAlt,omitempty"`
	MainMastAltId          *[]string                           `json:"mainMastAltId,omitempty"`
	MainMastExtId          *string                             `json:"mainMastExtId,omitempty"`
	MainMastId             *string                             `json:"mainMastId,omitempty"`
	MainMastLat            *float32                            `json:"mainMastLat,omitempty"`
	MainMastLon            *float32                            `json:"mainMastLon,omitempty"`
	Mcp                    *bool                               `json:"mcp,omitempty"`
	McpData                *[]KVType                           `json:"mcpData,omitempty"`
	McpInformation         *McpInformationType                 `json:"mcpInformation,omitempty"`
	MinimumChangeDuration  *string                             `json:"minimumChangeDuration,omitempty"`
	Name                   string                              `json:"name"`
	Platform               *PlatformType                       `json:"platform,omitempty"`
	PrognosisType          *OriginDestTypePrognosisType        `json:"prognosisType,omitempty"`
	PsCtxArriveEarlier     *string                             `json:"psCtxArriveEarlier,omitempty"`
	PsCtxDepartLater       *string                             `json:"psCtxDepartLater,omitempty"`
	RouteIdx               *int32                              `json:"routeIdx,omitempty"`
	RtAlighting            *bool                               `json:"rtAlighting,omitempty"`
	RtBoarding             *bool                               `json:"rtBoarding,omitempty"`
	RtCnclDataSourceType   *OriginDestTypeRtCnclDataSourceType `json:"rtCnclDataSourceType,omitempty"`
	RtDate                 *string                             `json:"rtDate,omitempty"`
	RtPlatform             *PlatformType                       `json:"rtPlatform,omitempty"`
	RtTime                 *string                             `json:"rtTime,omitempty"`
	RtTrack                *string                             `json:"rtTrack,omitempty"`
	RtTrackHidden          *bool                               `json:"rtTrackHidden,omitempty"`
	RtTz                   *int32                              `json:"rtTz,omitempty"`
	ScheduledTimeChanged   *bool                               `json:"scheduledTimeChanged,omitempty"`
	Time                   string                              `json:"time"`
	Track                  *string                             `json:"track,omitempty"`
	TrackHidden            *bool                               `json:"trackHidden,omitempty"`
	TrainCompositionMarker *int32                              `json:"trainCompositionMarker,omitempty"`
	Type                   string                              `json:"type"`
	Tz                     *int32                              `json:"tz,omitempty"`
	UncertainDelay         *bool                               `json:"uncertainDelay,omitempty"`
	WeatherInformation     *[]WeatherInformationType           `json:"weatherInformation,omitempty"`
}

// OriginDestTypePrognosisType defines model for OriginDestType.PrognosisType.
type OriginDestTypePrognosisType string

// OriginDestTypeRtCnclDataSourceType defines model for OriginDestType.RtCnclDataSourceType.
type OriginDestTypeRtCnclDataSourceType string

// ParallelJourneyRefType defines model for ParallelJourneyRefType.
type ParallelJourneyRefType struct {
	FromLocation     *StopType                       `json:"fromLocation,omitempty"`
	JourneyDetailRef *string                         `json:"journeyDetailRef,omitempty"`
	LinkType         *ParallelJourneyRefTypeLinkType `json:"linkType,omitempty"`
	ToLocation       *StopType                       `json:"toLocation,omitempty"`
	Type             *ParallelJourneyRefTypeType     `json:"type,omitempty"`
}

// ParallelJourneyRefTypeLinkType defines model for ParallelJourneyRefType.LinkType.
type ParallelJourneyRefTypeLinkType string

// ParallelJourneyRefTypeType defines model for ParallelJourneyRefType.Type.
type ParallelJourneyRefTypeType string

// PlatformType defines model for PlatformType.
type PlatformType struct {
	Alt    *int32            `json:"alt,omitempty"`
	AltId  *[]string         `json:"altId,omitempty"`
	Hidden *bool             `json:"hidden,omitempty"`
	Lat    *float32          `json:"lat,omitempty"`
	Lon    *float32          `json:"lon,omitempty"`
	Text   *string           `json:"text,omitempty"`
	Type   *PlatformTypeType `json:"type,omitempty"`
}

// PlatformTypeType defines model for PlatformType.Type.
type PlatformTypeType string

// Polyline defines model for Polyline.
type Polyline struct {
	Crd      *[]float64    `json:"crd,omitempty"`
	CrdEncS  *string       `json:"crdEncS,omitempty"`
	CrdEncYX *string       `json:"crdEncYX,omitempty"`
	CrdEncZ  *string       `json:"crdEncZ,omitempty"`
	Delta    bool          `json:"delta"`
	Dim      *int32        `json:"dim,omitempty"`
	Name     *string       `json:"name,omitempty"`
	Type     *PolylineType `json:"type,omitempty"`
}

// PolylineType defines model for Polyline.Type.
type PolylineType string

// PolylineDesc defines model for PolylineDesc.
type PolylineDesc struct {
	Crd      *[]float64 `json:"crd,omitempty"`
	CrdEncS  *string    `json:"crdEncS,omitempty"`
	CrdEncYX *string    `json:"crdEncYX,omitempty"`
	CrdEncZ  *string    `json:"crdEncZ,omitempty"`
	Delta    bool       `json:"delta"`
	Dim      *int32     `json:"dim,omitempty"`
	Name     *string    `json:"name,omitempty"`
}

// PolylineGroup defines model for PolylineGroup.
type PolylineGroup struct {
	CoordType    *PolylineGroupCoordType `json:"coordType,omitempty"`
	LayerName    *string                 `json:"layerName,omitempty"`
	Name         *string                 `json:"name,omitempty"`
	PolylineDesc *[]PolylineDesc         `json:"polylineDesc,omitempty"`
}

// PolylineGroupCoordType defines model for PolylineGroup.CoordType.
type PolylineGroupCoordType string

// PricingType defines model for PricingType.
type PricingType struct {
	Any *map[string]interface{} `json:"any,omitempty"`
	Idx int32                   `json:"idx"`
}

// ProductCategoryType defines model for ProductCategoryType.
type ProductCategoryType struct {
	Product *[]ProductType `json:"Product,omitempty"`
	Cls     *string        `json:"cls,omitempty"`
	Name    string         `json:"name"`
}

// ProductStatusType defines model for ProductStatusType.
type ProductStatusType struct {
	Code   *int32    `json:"code,omitempty"`
	Icon   *IconType `json:"icon,omitempty"`
	RtIcon *IconType `json:"rtIcon,omitempty"`
	Txt    *string   `json:"txt,omitempty"`
}

// ProductType defines model for ProductType.
type ProductType struct {
	Message       *[]Message         `json:"Message,omitempty"`
	Note          *[]Note            `json:"Note,omitempty"`
	AddName       *string            `json:"addName,omitempty"`
	Admin         *string            `json:"admin,omitempty"`
	CatCode       *string            `json:"catCode,omitempty"`
	CatIn         *string            `json:"catIn,omitempty"`
	CatOut        *string            `json:"catOut,omitempty"`
	CatOutL       *string            `json:"catOutL,omitempty"`
	CatOutS       *string            `json:"catOutS,omitempty"`
	Cls           *string            `json:"cls,omitempty"`
	DisplayNumber *string            `json:"displayNumber,omitempty"`
	FromLocation  *StopType          `json:"fromLocation,omitempty"`
	Icon          *IconType          `json:"icon,omitempty"`
	InternalName  *string            `json:"internalName,omitempty"`
	Line          *string            `json:"line,omitempty"`
	LineHidden    *bool              `json:"lineHidden,omitempty"`
	LineId        *string            `json:"lineId,omitempty"`
	LocTraffic    *string            `json:"locTraffic,omitempty"`
	MatchId       *string            `json:"matchId,omitempty"`
	Name          *string            `json:"name,omitempty"`
	Num           *string            `json:"num,omitempty"`
	Operator      *string            `json:"operator,omitempty"`
	OperatorCode  *string            `json:"operatorCode,omitempty"`
	OperatorInfo  *OperatorType      `json:"operatorInfo,omitempty"`
	OutCtrl       *string            `json:"outCtrl,omitempty"`
	RouteIdxFrom  *int32             `json:"routeIdxFrom,omitempty"`
	RouteIdxTo    *int32             `json:"routeIdxTo,omitempty"`
	ShipTraffic   *string            `json:"shipTraffic,omitempty"`
	Status        *ProductStatusType `json:"status,omitempty"`
	Surcharge     *string            `json:"surcharge,omitempty"`
	TarGr         *string            `json:"tarGr,omitempty"`
	ToLocation    *StopType          `json:"toLocation,omitempty"`
}

// RGBAColorType defines model for RGBAColorType.
type RGBAColorType struct {
	A   *int32  `json:"a,omitempty"`
	B   *int32  `json:"b,omitempty"`
	G   *int32  `json:"g,omitempty"`
	Hex *string `json:"hex,omitempty"`
	R   *int32  `json:"r,omitempty"`
}

// Rect defines model for Rect.
type Rect struct {
	LlCrd Coordinate `json:"llCrd"`
	UrCrd Coordinate `json:"urCrd"`
}

// ReferencedJourneyType defines model for ReferencedJourneyType.
type ReferencedJourneyType struct {
	Journey     *JourneyType              `json:"journey,omitempty"`
	OrigFromIdx *int32                    `json:"origFromIdx,omitempty"`
	OrigToIdx   *int32                    `json:"origToIdx,omitempty"`
	RefFromIdx  *int32                    `json:"refFromIdx,omitempty"`
	RefToIdx    *int32                    `json:"refToIdx,omitempty"`
	Type        ReferencedJourneyTypeType `json:"type"`
}

// ReferencedJourneyTypeType defines model for ReferencedJourneyType.Type.
type ReferencedJourneyTypeType string

// RegionType defines model for RegionType.
type RegionType struct {
	ExtId int32   `json:"extId"`
	Name  *string `json:"name,omitempty"`
}

// ResourceLinkType defines model for ResourceLinkType.
type ResourceLinkType struct {
	Href string `json:"href"`
	Rel  string `json:"rel"`
}

// ResourceLinks defines model for ResourceLinks.
type ResourceLinks struct {
	Link *[]ResourceLinkType `json:"link,omitempty"`
}

// ResultStatusType defines model for ResultStatusType.
type ResultStatusType struct {
	TimeDiffCritical *bool `json:"timeDiffCritical,omitempty"`
}

// Ring defines model for Ring.
type Ring struct {
	Lat       float32 `json:"lat"`
	Lon       float32 `json:"lon"`
	MaxRadius *int32  `json:"maxRadius,omitempty"`
	MinRadius *int32  `json:"minRadius,omitempty"`
}

// ServiceDays defines model for ServiceDays.
type ServiceDays struct {
	PlanningPeriodBegin *string `json:"planningPeriodBegin,omitempty"`
	PlanningPeriodEnd   *string `json:"planningPeriodEnd,omitempty"`
	RouteIdxFrom        *int32  `json:"routeIdxFrom,omitempty"`
	RouteIdxTo          *int32  `json:"routeIdxTo,omitempty"`
	SDaysB              *string `json:"sDaysB,omitempty"`
	SDaysI              *string `json:"sDaysI,omitempty"`
	SDaysR              *string `json:"sDaysR,omitempty"`
}

// SortingGroupType defines model for SortingGroupType.
type SortingGroupType struct {
	Name   *string               `json:"name,omitempty"`
	TripId []string              `json:"tripId"`
	Type   *SortingGroupTypeType `json:"type,omitempty"`
}

// SortingGroupTypeType defines model for SortingGroupType.Type.
type SortingGroupTypeType string

// SortingType defines model for SortingType.
type SortingType struct {
	SortingGroup       *[]SortingGroupType            `json:"SortingGroup,omitempty"`
	InitialSortingType *SortingTypeInitialSortingType `json:"initialSortingType,omitempty"`
	Scrollable         *bool                          `json:"scrollable,omitempty"`
}

// SortingTypeInitialSortingType defines model for SortingType.InitialSortingType.
type SortingTypeInitialSortingType string

// SotContextType defines model for SotContextType.
type SotContextType struct {
	CalcDate                      *string               `json:"calcDate,omitempty"`
	CalcTime                      *string               `json:"calcTime,omitempty"`
	CurLoc                        *Location             `json:"curLoc,omitempty"`
	CurLocRouteIdx                *int32                `json:"curLocRouteIdx,omitempty"`
	JourneyId                     *string               `json:"journeyId,omitempty"`
	LegId                         *string               `json:"legId,omitempty"`
	LegIdFootPathConnection       *string               `json:"legIdFootPathConnection,omitempty"`
	LegIdx                        *int32                `json:"legIdx,omitempty"`
	LegIdxFootPathConnection      *int32                `json:"legIdxFootPathConnection,omitempty"`
	LocFootPathConnection         *Location             `json:"locFootPathConnection,omitempty"`
	LocMode                       SotContextTypeLocMode `json:"locMode"`
	LocRouteIdxFootPathConnection *int32                `json:"locRouteIdxFootPathConnection,omitempty"`
	PrevLoc                       *Location             `json:"prevLoc,omitempty"`
	PrevLocRouteIdx               *int32                `json:"prevLocRouteIdx,omitempty"`
	TrainName                     *string               `json:"trainName,omitempty"`
}

// SotContextTypeLocMode defines model for SotContextType.LocMode.
type SotContextTypeLocMode string

// StopLocation defines model for StopLocation.
type StopLocation struct {
	LocationNotes          *LocationNotes            `json:"LocationNotes,omitempty"`
	Message                *[]Message                `json:"Message,omitempty"`
	TariffResult           *TariffResult             `json:"TariffResult,omitempty"`
	Alt                    *int32                    `json:"alt,omitempty"`
	AltId                  *[]string                 `json:"altId,omitempty"`
	AssignedPois           *[]CoordLocation          `json:"assignedPois,omitempty"`
	DefName                *string                   `json:"defName,omitempty"`
	Description            *string                   `json:"description,omitempty"`
	Dist                   *int32                    `json:"dist,omitempty"`
	Entry                  *bool                     `json:"entry,omitempty"`
	EntryPointLocation     *[]StopLocation           `json:"entryPointLocation,omitempty"`
	EquivalentStopLocation *[]StopLocation           `json:"equivalentStopLocation,omitempty"`
	ExtId                  string                    `json:"extId"`
	HasMainMast            *bool                     `json:"hasMainMast,omitempty"`
	Id                     string                    `json:"id"`
	IsMainMast             *bool                     `json:"isMainMast,omitempty"`
	Lat                    *float32                  `json:"lat,omitempty"`
	Links                  *[]ResourceLinks          `json:"links,omitempty"`
	Lon                    *float32                  `json:"lon,omitempty"`
	MainMast               *StopLocation             `json:"mainMast,omitempty"`
	MainMastAlt            *int32                    `json:"mainMastAlt,omitempty"`
	MainMastAltId          *[]string                 `json:"mainMastAltId,omitempty"`
	MainMastExtId          *string                   `json:"mainMastExtId,omitempty"`
	MainMastId             *string                   `json:"mainMastId,omitempty"`
	MainMastLat            *float32                  `json:"mainMastLat,omitempty"`
	MainMastLon            *float32                  `json:"mainMastLon,omitempty"`
	MatchValue             *int32                    `json:"matchValue,omitempty"`
	Meta                   *bool                     `json:"meta,omitempty"`
	MinimumChangeDuration  *string                   `json:"minimumChangeDuration,omitempty"`
	Name                   string                    `json:"name"`
	ProductAtStop          *[]ProductType            `json:"productAtStop,omitempty"`
	Products               *int32                    `json:"products,omitempty"`
	Refinable              *bool                     `json:"refinable,omitempty"`
	TimezoneOffset         *int32                    `json:"timezoneOffset,omitempty"`
	Track                  *string                   `json:"track,omitempty"`
	TrackHidden            *bool                     `json:"trackHidden,omitempty"`
	WeatherInformation     *[]WeatherInformationType `json:"weatherInformation,omitempty"`
	Weight                 *int32                    `json:"weight,omitempty"`
}

// StopType defines model for StopType.
type StopType struct {
	Notes                   *Notes                        `json:"Notes,omitempty"`
	Occupancy               *[]OccupancyType              `json:"Occupancy,omitempty"`
	Additional              *bool                         `json:"additional,omitempty"`
	Alighting               *bool                         `json:"alighting,omitempty"`
	Alt                     *int32                        `json:"alt,omitempty"`
	AltId                   *[]string                     `json:"altId,omitempty"`
	ArrDate                 *string                       `json:"arrDate,omitempty"`
	ArrHide                 *bool                         `json:"arrHide,omitempty"`
	ArrPlatform             *PlatformType                 `json:"arrPlatform,omitempty"`
	ArrPrognosisType        *StopTypeArrPrognosisType     `json:"arrPrognosisType,omitempty"`
	ArrTime                 *string                       `json:"arrTime,omitempty"`
	ArrTrack                *string                       `json:"arrTrack,omitempty"`
	ArrTrackHidden          *bool                         `json:"arrTrackHidden,omitempty"`
	ArrTz                   *int32                        `json:"arrTz,omitempty"`
	ArrUncertainDelay       *bool                         `json:"arrUncertainDelay,omitempty"`
	Boarding                *bool                         `json:"boarding,omitempty"`
	Cancelled               *bool                         `json:"cancelled,omitempty"`
	CancelledArrival        *bool                         `json:"cancelledArrival,omitempty"`
	CancelledDeparture      *bool                         `json:"cancelledDeparture,omitempty"`
	DepDate                 *string                       `json:"depDate,omitempty"`
	DepDir                  *string                       `json:"depDir,omitempty"`
	DepHide                 *bool                         `json:"depHide,omitempty"`
	DepPlatform             *PlatformType                 `json:"depPlatform,omitempty"`
	DepPrognosisType        *StopTypeDepPrognosisType     `json:"depPrognosisType,omitempty"`
	DepTime                 *string                       `json:"depTime,omitempty"`
	DepTrack                *string                       `json:"depTrack,omitempty"`
	DepTrackHidden          *bool                         `json:"depTrackHidden,omitempty"`
	DepTz                   *int32                        `json:"depTz,omitempty"`
	DepUncertainDelay       *bool                         `json:"depUncertainDelay,omitempty"`
	Description             *string                       `json:"description,omitempty"`
	Entry                   *bool                         `json:"entry,omitempty"`
	ExtId                   string                        `json:"extId"`
	HasMainMast             *bool                         `json:"hasMainMast,omitempty"`
	Id                      string                        `json:"id"`
	IsBorderStop            *bool                         `json:"isBorderStop,omitempty"`
	IsMainMast              *bool                         `json:"isMainMast,omitempty"`
	IsTurningPoint          *bool                         `json:"isTurningPoint,omitempty"`
	Lat                     *float32                      `json:"lat,omitempty"`
	Lon                     *float32                      `json:"lon,omitempty"`
	MainMast                *StopLocation                 `json:"mainMast,omitempty"`
	MainMastAlt             *int32                        `json:"mainMastAlt,omitempty"`
	MainMastAltId           *[]string                     `json:"mainMastAltId,omitempty"`
	MainMastExtId           *string                       `json:"mainMastExtId,omitempty"`
	MainMastId              *string                       `json:"mainMastId,omitempty"`
	MainMastLat             *float32                      `json:"mainMastLat,omitempty"`
	MainMastLon             *float32                      `json:"mainMastLon,omitempty"`
	MinimumChangeDuration   *string                       `json:"minimumChangeDuration,omitempty"`
	Name                    string                        `json:"name"`
	PassingDate             *string                       `json:"passingDate,omitempty"`
	PassingTime             *string                       `json:"passingTime,omitempty"`
	PassingTz               *int32                        `json:"passingTz,omitempty"`
	RouteIdx                *int32                        `json:"routeIdx,omitempty"`
	RtAlighting             *bool                         `json:"rtAlighting,omitempty"`
	RtArrDate               *string                       `json:"rtArrDate,omitempty"`
	RtArrPlatform           *PlatformType                 `json:"rtArrPlatform,omitempty"`
	RtArrTime               *string                       `json:"rtArrTime,omitempty"`
	RtArrTrack              *string                       `json:"rtArrTrack,omitempty"`
	RtArrTrackHidden        *bool                         `json:"rtArrTrackHidden,omitempty"`
	RtArrTz                 *int32                        `json:"rtArrTz,omitempty"`
	RtBoarding              *bool                         `json:"rtBoarding,omitempty"`
	RtCnclDataSourceType    *StopTypeRtCnclDataSourceType `json:"rtCnclDataSourceType,omitempty"`
	RtDepDate               *string                       `json:"rtDepDate,omitempty"`
	RtDepPlatform           *PlatformType                 `json:"rtDepPlatform,omitempty"`
	RtDepTime               *string                       `json:"rtDepTime,omitempty"`
	RtDepTrack              *string                       `json:"rtDepTrack,omitempty"`
	RtDepTrackHidden        *bool                         `json:"rtDepTrackHidden,omitempty"`
	RtDepTz                 *int32                        `json:"rtDepTz,omitempty"`
	RtPassingDate           *string                       `json:"rtPassingDate,omitempty"`
	RtPassingTime           *string                       `json:"rtPassingTime,omitempty"`
	RtPassingTz             *int32                        `json:"rtPassingTz,omitempty"`
	ScheduledArrTimeChanged *bool                         `json:"scheduledArrTimeChanged,omitempty"`
	ScheduledDepTimeChanged *bool                         `json:"scheduledDepTimeChanged,omitempty"`
	WeatherInformation      *[]WeatherInformationType     `json:"weatherInformation,omitempty"`
}

// StopTypeArrPrognosisType defines model for StopType.ArrPrognosisType.
type StopTypeArrPrognosisType string

// StopTypeDepPrognosisType defines model for StopType.DepPrognosisType.
type StopTypeDepPrognosisType string

// StopTypeRtCnclDataSourceType defines model for StopType.RtCnclDataSourceType.
type StopTypeRtCnclDataSourceType string

// Stops defines model for Stops.
type Stops struct {
	Stop []StopType `json:"Stop"`
}

// TagsType defines model for TagsType.
type TagsType struct {
	Tag []string `json:"tag"`
}

// TariffResult defines model for TariffResult.
type TariffResult struct {
	Clickout        *string              `json:"clickout,omitempty"`
	ExternalContent *ExternalContentType `json:"externalContent,omitempty"`
	FareSetItem     *[]FareSetItem       `json:"fareSetItem,omitempty"`
	Param           *[]KVType            `json:"param,omitempty"`
}

// TechnicalMessage defines model for TechnicalMessage.
type TechnicalMessage struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// TechnicalMessages defines model for TechnicalMessages.
type TechnicalMessages struct {
	TechnicalMessage *[]TechnicalMessage `json:"TechnicalMessage,omitempty"`
}

// Ticket defines model for Ticket.
type Ticket struct {
	Cur             *string              `json:"cur,omitempty"`
	Desc            *string              `json:"desc,omitempty"`
	ExternalContent *ExternalContentType `json:"externalContent,omitempty"`
	FromLeg         *int32               `json:"fromLeg,omitempty"`
	FromLegId       *string              `json:"fromLegId,omitempty"`
	Name            *string              `json:"name,omitempty"`
	Param           *[]KVType            `json:"param,omitempty"`
	Price           *int32               `json:"price,omitempty"`
	ShpCtx          *string              `json:"shpCtx,omitempty"`
	ToLeg           *int32               `json:"toLeg,omitempty"`
	ToLegId         *string              `json:"toLegId,omitempty"`
}

// TrafficMessageType defines model for TrafficMessageType.
type TrafficMessageType struct {
	PolylineGroup *PolylineGroup          `json:"PolylineGroup,omitempty"`
	Desc          *string                 `json:"desc,omitempty"`
	ExtId         *string                 `json:"extId,omitempty"`
	Icon          *IconType               `json:"icon,omitempty"`
	Id            *string                 `json:"id,omitempty"`
	Location      *StopLocation           `json:"location,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	Type          *TrafficMessageTypeType `json:"type,omitempty"`
}

// TrafficMessageTypeType defines model for TrafficMessageType.Type.
type TrafficMessageTypeType string

// TripList defines model for TripList.
type TripList struct {
	Pricing              *[]PricingType     `json:"Pricing,omitempty"`
	ResultStatus         *ResultStatusType  `json:"ResultStatus,omitempty"`
	Sorting              *SortingType       `json:"Sorting,omitempty"`
	SotContext           *SotContextType    `json:"SotContext,omitempty"`
	TechnicalMessages    *TechnicalMessages `json:"TechnicalMessages,omitempty"`
	Trip                 *[]TripType        `json:"Trip,omitempty"`
	Warnings             *Warnings          `json:"Warnings,omitempty"`
	DialectVersion       *string            `json:"dialectVersion,omitempty"`
	ErrorCode            *string            `json:"errorCode,omitempty"`
	ErrorText            *string            `json:"errorText,omitempty"`
	InternalErrorCode    *string            `json:"internalErrorCode,omitempty"`
	InternalErrorText    *string            `json:"internalErrorText,omitempty"`
	InternalErrorTextOut *string            `json:"internalErrorTextOut,omitempty"`
	PlanRtTs             *time.Time         `json:"planRtTs,omitempty"`
	RequestId            *string            `json:"requestId,omitempty"`
	ScrB                 *string            `json:"scrB,omitempty"`
	ScrF                 *string            `json:"scrF,omitempty"`
	ScrReturnB           *string            `json:"scrReturnB,omitempty"`
	ScrReturnF           *string            `json:"scrReturnF,omitempty"`
	ServerVersion        *string            `json:"serverVersion,omitempty"`
	Version              *string            `json:"version,omitempty"`
}

// TripStatusType defines model for TripStatusType.
type TripStatusType struct {
	Convenient                     *bool   `json:"convenient,omitempty"`
	Daily                          *bool   `json:"daily,omitempty"`
	Detour                         *bool   `json:"detour,omitempty"`
	Direct                         *bool   `json:"direct,omitempty"`
	Economic                       *bool   `json:"economic,omitempty"`
	Hint                           *string `json:"hint,omitempty"`
	HintCode                       *int32  `json:"hintCode,omitempty"`
	SlowDirect                     *bool   `json:"slowDirect,omitempty"`
	Specialtrain                   *bool   `json:"specialtrain,omitempty"`
	SubOptimalDirect               *bool   `json:"subOptimalDirect,omitempty"`
	TimeDiffCritical               *bool   `json:"timeDiffCritical,omitempty"`
	UkNationalRouteingGuideFailure *bool   `json:"ukNationalRouteingGuideFailure,omitempty"`
	Unsharp                        *bool   `json:"unsharp,omitempty"`
}

// TripType defines model for TripType.
type TripType struct {
	Destination           OriginDestType             `json:"Destination"`
	Eco                   *EcoType                   `json:"Eco,omitempty"`
	EcoCmp                *[]EcoType                 `json:"EcoCmp,omitempty"`
	Freq                  *FreqType                  `json:"Freq,omitempty"`
	LegList               LegList                    `json:"LegList"`
	Messages              *Messages                  `json:"Messages,omitempty"`
	Notes                 *Notes                     `json:"Notes,omitempty"`
	Occupancy             *[]OccupancyType           `json:"Occupancy,omitempty"`
	Origin                OriginDestType             `json:"Origin"`
	ServiceDays           *[]ServiceDays             `json:"ServiceDays,omitempty"`
	TariffResult          *TariffResult              `json:"TariffResult,omitempty"`
	TripStatus            *TripStatusType            `json:"TripStatus,omitempty"`
	Alternative           *bool                      `json:"alternative,omitempty"`
	CalBurned             *int32                     `json:"calBurned,omitempty"`
	Calculation           *TripTypeCalculation       `json:"calculation,omitempty"`
	Checksum              *string                    `json:"checksum,omitempty"`
	CombinedCount         *int32                     `json:"combinedCount,omitempty"`
	CombinedMinDuration   *string                    `json:"combinedMinDuration,omitempty"`
	CtxRecon              *string                    `json:"ctxRecon,omitempty"`
	Dist                  *int32                     `json:"dist,omitempty"`
	Duration              *string                    `json:"duration,omitempty"`
	EcoUrl                *string                    `json:"ecoUrl,omitempty"`
	HasAlternative        *bool                      `json:"hasAlternative,omitempty"`
	HasDelayInfo          *bool                      `json:"hasDelayInfo,omitempty"`
	Idx                   *int32                     `json:"idx,omitempty"`
	IndividualChangeTimes *bool                      `json:"individualChangeTimes,omitempty"`
	Reliability           *ConnectionReliabilityType `json:"reliability,omitempty"`
	Return                *bool                      `json:"return,omitempty"`
	RtDuration            *string                    `json:"rtDuration,omitempty"`
	TransferCount         *int32                     `json:"transferCount,omitempty"`
	TripId                *string                    `json:"tripId,omitempty"`
	Valid                 *bool                      `json:"valid,omitempty"`
	Via                   *[]StopType                `json:"via,omitempty"`
}

// TripTypeCalculation defines model for TripType.Calculation.
type TripTypeCalculation string

// UrlLinkType defines model for UrlLinkType.
type UrlLinkType struct {
	Name *string `json:"name,omitempty"`
	Url  string  `json:"url"`
}

// Warning defines model for Warning.
type Warning struct {
	Key     *string `json:"key,omitempty"`
	Message *string `json:"message,omitempty"`
}

// Warnings defines model for Warnings.
type Warnings struct {
	Warning *[]Warning `json:"Warning,omitempty"`
}

// WeatherInformationType defines model for WeatherInformationType.
type WeatherInformationType struct {
	Date    string                     `json:"date"`
	Icon    *IconType                  `json:"icon,omitempty"`
	Summary *string                    `json:"summary,omitempty"`
	Temp    *string                    `json:"temp,omitempty"`
	Text    *string                    `json:"text,omitempty"`
	Time    *string                    `json:"time,omitempty"`
	Type    WeatherInformationTypeType `json:"type"`
}

// WeatherInformationTypeType defines model for WeatherInformationType.Type.
type WeatherInformationTypeType string

// Verb1Params defines parameters for Verb1.
type Verb1Params struct {
	// RequestId Request ID for identifying the request. String not longer than 2048.
	RequestId *string `form:"requestId,omitempty" json:"requestId,omitempty"`

	// Format Requested response format. If not set, the Accept-Header is used. If both are missing application/xml is used
	Format *Verb1ParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// JsonpCallback Requests the JSON response data is wrapped into a JavaScript function with that name. String not longer than 1024.
	JsonpCallback *string `form:"jsonpCallback,omitempty" json:"jsonpCallback,omitempty"`

	// Lang The language of the journey planer. String not longer than 5.
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`

	// Id Specifies the station/stop ID for which the arrivals shall be retrieved. Required if extId is not present. String not longer than 512.
	//
	// Since version: 1.0
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// ExtId Deprecated. Please use `id` as it supports external IDs.
	//
	// Specifies the external station/stop ID for which the arrivals shall be retrieved. Required if id is not present. String not longer than 512.
	//
	// Since version: 1.21
	ExtId *string `form:"extId,omitempty" json:"extId,omitempty"`

	// Direction If only vehicles departing or arriving from a certain direction shall be returned, specify the direction by giving the station/stop ID of the last stop on the journey. String not longer than 512.
	//
	// Since version: 1.0
	Direction *string `form:"direction,omitempty" json:"direction,omitempty"`

	// Date Sets the start date for which the departures shall be retrieved. Represented in the format YYYY-MM-DD.
	//
	// Since version: 1.0
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// Time Sets the start time for which the departures shall be retrieved. Represented in the format hh:mm[:ss] in 24h nomenclature. Seconds will be ignored for requests.
	//
	// Since version: 1.0
	Time *string `form:"time,omitempty" json:"time,omitempty"`

	// Duration Set the interval size in minutes. Range: 0-1439
	//
	// Since version: 1.0
	Duration *int `form:"duration,omitempty" json:"duration,omitempty"`

	// MaxJourneys Maximum number of journeys to be returned. If no value is defined or -1, all departing/arriving services within the duration sized period are returned. Minimum of -1.
	//
	// Since version: 1.0
	MaxJourneys *int `form:"maxJourneys,omitempty" json:"maxJourneys,omitempty"`

	// Products Decimal value defining the product classes to be included in the search. It represents a bitmask combining bit number of a product as defined in the HAFAS raw data. Values are retrievable by <<service_datainfo,Data Information service>>. Minimum of 0.
	//
	// Since version: 1.12
	Products *int `form:"products,omitempty" json:"products,omitempty"`

	// Operators Only journeys provided by the given operators are part of the result. To filter multiple operators, separate the codes by comma.
	// If the operator should not be part of the journeys, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.0
	Operators *string `form:"operators,omitempty" json:"operators,omitempty"`

	// Categories Only journeys provided by the given categories are part of the result. To filter multiple categories, separate the codes by comma.
	// If the category should not be part of the journeys, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 2.25
	Categories *string `form:"categories,omitempty" json:"categories,omitempty"`

	// Lines Only journeys running the given line are part of the result. To filter multiple lines, separate the codes by comma. If the line should not be part of the be trip, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.0
	Lines *string `form:"lines,omitempty" json:"lines,omitempty"`

	// Attributes Filter boards by one or more attribute codes of a journey. Multiple attribute codes are separated by comma. If the attribute should not be part of the result, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.0
	Attributes *string `form:"attributes,omitempty" json:"attributes,omitempty"`

	// Platforms Filter boards by platform. Multiple platforms are separated by comma. String not longer than 1024.
	//
	// Since version: 2.7.2
	Platforms *string `form:"platforms,omitempty" json:"platforms,omitempty"`

	// Passlist Include a list of all passed waystops?
	//
	// Since version: 1.0
	Passlist *Verb1ParamsPasslist `form:"passlist,omitempty" json:"passlist,omitempty"`

	// PasslistMaxStops Maximum number of stops including requested stop and last stop. Minimum of 0.
	//
	// Since version: 1.0
	PasslistMaxStops *int `form:"passlistMaxStops,omitempty" json:"passlistMaxStops,omitempty"`

	// MinDur Minimum duration a journey has left to be returned. Minimum of 0.
	//
	// Since version: 1.0
	MinDur *int `form:"minDur,omitempty" json:"minDur,omitempty"`

	// Baim Enables/disables BAIM information.
	//
	// Since version: 2.26
	Baim *Verb1ParamsBaim `form:"baim,omitempty" json:"baim,omitempty"`

	// RtMode Set the realtime mode to be used.
	//
	// Since version: 2.34
	RtMode *Verb1ParamsRtMode `form:"rtMode,omitempty" json:"rtMode,omitempty"`

	// Type Set the station arrival board type to be used.
	//
	// ARR: Arrival board as configured in HAFAS
	// ARR_EQUIVS: Arrival board with all journeys at any masts and equivalent stops
	// ARR_MAST: Arrival board at mast
	// ARR_STATION: Arrival board with all journeys at any masts of the requested station
	//
	// Since version: 2.12
	Type Verb1ParamsType `form:"type" json:"type"`
}

// Verb1ParamsFormat defines parameters for Verb1.
type Verb1ParamsFormat string

// Verb1ParamsPasslist defines parameters for Verb1.
type Verb1ParamsPasslist string

// Verb1ParamsBaim defines parameters for Verb1.
type Verb1ParamsBaim string

// Verb1ParamsRtMode defines parameters for Verb1.
type Verb1ParamsRtMode string

// Verb1ParamsType defines parameters for Verb1.
type Verb1ParamsType string

// Verb2Params defines parameters for Verb2.
type Verb2Params struct {
	// RequestId Request ID for identifying the request. String not longer than 2048.
	RequestId *string `form:"requestId,omitempty" json:"requestId,omitempty"`

	// Format Requested response format. If not set, the Accept-Header is used. If both are missing application/xml is used
	Format *Verb2ParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// JsonpCallback Requests the JSON response data is wrapped into a JavaScript function with that name. String not longer than 1024.
	JsonpCallback *string `form:"jsonpCallback,omitempty" json:"jsonpCallback,omitempty"`

	// Lang The language of the journey planer. String not longer than 5.
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`
}

// Verb2ParamsFormat defines parameters for Verb2.
type Verb2ParamsFormat string

// Verb3Params defines parameters for Verb3.
type Verb3Params struct {
	// RequestId Request ID for identifying the request. String not longer than 2048.
	RequestId *string `form:"requestId,omitempty" json:"requestId,omitempty"`

	// Format Requested response format. If not set, the Accept-Header is used. If both are missing application/xml is used
	Format *Verb3ParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// JsonpCallback Requests the JSON response data is wrapped into a JavaScript function with that name. String not longer than 1024.
	JsonpCallback *string `form:"jsonpCallback,omitempty" json:"jsonpCallback,omitempty"`

	// Lang The language of the journey planer. String not longer than 5.
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`

	// Id Specifies the station/stop ID for which the departures shall be retrieved. Required if extId is not present. String not longer than 512.
	//
	// Since version: 1.0
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// ExtId Deprecated. Please use `id` as it supports external IDs.
	//
	// Specifies the external station/stop ID for which the departures shall be retrieved. Required if id is not present. String not longer than 512.
	//
	// Since version: 1.21
	ExtId *string `form:"extId,omitempty" json:"extId,omitempty"`

	// Direction If only vehicles departing or arriving from a certain direction shall be returned, specify the direction by giving the station/stop ID of the last stop on the journey. String not longer than 512.
	//
	// Since version: 1.0
	Direction *string `form:"direction,omitempty" json:"direction,omitempty"`

	// Date Sets the start date for which the departures shall be retrieved. Represented in the format YYYY-MM-DD.
	//
	// Since version: 1.0
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// Time Sets the start time for which the departures shall be retrieved. Represented in the format hh:mm[:ss] in 24h nomenclature. Seconds will be ignored for requests.
	//
	// Since version: 1.0
	Time *string `form:"time,omitempty" json:"time,omitempty"`

	// Duration Set the interval size in minutes. Range: 0-1439
	//
	// Since version: 1.0
	Duration *int `form:"duration,omitempty" json:"duration,omitempty"`

	// MaxJourneys Maximum number of journeys to be returned. If no value is defined or -1, all departing/arriving services within the duration sized period are returned. Minimum of -1.
	//
	// Since version: 1.0
	MaxJourneys *int `form:"maxJourneys,omitempty" json:"maxJourneys,omitempty"`

	// Products Decimal value defining the product classes to be included in the search. It represents a bitmask combining bit number of a product as defined in the HAFAS raw data. Values are retrievable by <<service_datainfo,Data Information service>>. Minimum of 0.
	//
	// Since version: 1.12
	Products *int `form:"products,omitempty" json:"products,omitempty"`

	// Operators Only journeys provided by the given operators are part of the result. To filter multiple operators, separate the codes by comma.
	// If the operator should not be part of the journeys, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.0
	Operators *string `form:"operators,omitempty" json:"operators,omitempty"`

	// Categories Only journeys provided by the given categories are part of the result. To filter multiple categories, separate the codes by comma.
	// If the category should not be part of the journeys, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 2.25
	Categories *string `form:"categories,omitempty" json:"categories,omitempty"`

	// Lines Only journeys running the given line are part of the result. To filter multiple lines, separate the codes by comma. If the line should not be part of the be trip, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.0
	Lines *string `form:"lines,omitempty" json:"lines,omitempty"`

	// Attributes Filter boards by one or more attribute codes of a journey. Multiple attribute codes are separated by comma. If the attribute should not be part of the result, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.0
	Attributes *string `form:"attributes,omitempty" json:"attributes,omitempty"`

	// Platforms Filter boards by platform. Multiple platforms are separated by comma. String not longer than 1024.
	//
	// Since version: 2.7.2
	Platforms *string `form:"platforms,omitempty" json:"platforms,omitempty"`

	// Passlist Include a list of all passed waystops?
	//
	// Since version: 1.0
	Passlist *Verb3ParamsPasslist `form:"passlist,omitempty" json:"passlist,omitempty"`

	// PasslistMaxStops Maximum number of stops including requested stop and last stop. Minimum of 0.
	//
	// Since version: 1.0
	PasslistMaxStops *int `form:"passlistMaxStops,omitempty" json:"passlistMaxStops,omitempty"`

	// MinDur Minimum duration a journey has left to be returned. Minimum of 0.
	//
	// Since version: 1.0
	MinDur *int `form:"minDur,omitempty" json:"minDur,omitempty"`

	// Baim Enables/disables BAIM information.
	//
	// Since version: 2.26
	Baim *Verb3ParamsBaim `form:"baim,omitempty" json:"baim,omitempty"`

	// RtMode Set the realtime mode to be used.
	//
	// Since version: 2.34
	RtMode *Verb3ParamsRtMode `form:"rtMode,omitempty" json:"rtMode,omitempty"`

	// Type Set the station departure board type to be used.
	//
	// DEP: Departure board as configured in HAFAS
	// DEP_EQUIVS: Departure board with all journeys at any masts and equivalent stops
	// DEP_MAST: Departure board at mast
	// DEP_STATION: Departure board with all journeys at any masts of the requested station
	//
	// Since version: 2.12
	Type Verb3ParamsType `form:"type" json:"type"`
}

// Verb3ParamsFormat defines parameters for Verb3.
type Verb3ParamsFormat string

// Verb3ParamsPasslist defines parameters for Verb3.
type Verb3ParamsPasslist string

// Verb3ParamsBaim defines parameters for Verb3.
type Verb3ParamsBaim string

// Verb3ParamsRtMode defines parameters for Verb3.
type Verb3ParamsRtMode string

// Verb3ParamsType defines parameters for Verb3.
type Verb3ParamsType string

// Verb4Params defines parameters for Verb4.
type Verb4Params struct {
	// RequestId Request ID for identifying the request. String not longer than 2048.
	RequestId *string `form:"requestId,omitempty" json:"requestId,omitempty"`

	// Format Requested response format. If not set, the Accept-Header is used. If both are missing application/xml is used
	Format *Verb4ParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// JsonpCallback Requests the JSON response data is wrapped into a JavaScript function with that name. String not longer than 1024.
	JsonpCallback *string `form:"jsonpCallback,omitempty" json:"jsonpCallback,omitempty"`

	// Lang The language of the journey planer. String not longer than 5.
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`

	// Ctx Specifies the GIS route context. String not longer than 8096.
	//
	// Since version: 1.0
	Ctx string `form:"ctx" json:"ctx"`

	// Poly Enables/disables the calculation of the polyline.
	//
	// Since version: 1.11
	Poly *Verb4ParamsPoly `form:"poly,omitempty" json:"poly,omitempty"`

	// PolyEnc Defines encoding of the returned polyline. Possible values are N (no encoding / compression), DLT (delta to the previous coordinate), GPA (Google encoded polyline format) defaults to N. Not all option might be available in your installation.
	//
	// Since version: 1.11
	PolyEnc *Verb4ParamsPolyEnc `form:"polyEnc,omitempty" json:"polyEnc,omitempty"`

	// Eco Enables/disables eco value calculation.
	//
	// Since version: 1.23.9
	Eco *Verb4ParamsEco `form:"eco,omitempty" json:"eco,omitempty"`

	// Baim Enables/disables BAIM.
	//
	// Since version: 2.39
	Baim *Verb4ParamsBaim `form:"baim,omitempty" json:"baim,omitempty"`
}

// Verb4ParamsFormat defines parameters for Verb4.
type Verb4ParamsFormat string

// Verb4ParamsPoly defines parameters for Verb4.
type Verb4ParamsPoly string

// Verb4ParamsPolyEnc defines parameters for Verb4.
type Verb4ParamsPolyEnc string

// Verb4ParamsEco defines parameters for Verb4.
type Verb4ParamsEco string

// Verb4ParamsBaim defines parameters for Verb4.
type Verb4ParamsBaim string

// Verb5Params defines parameters for Verb5.
type Verb5Params struct {
	// RequestId Request ID for identifying the request. String not longer than 2048.
	RequestId *string `form:"requestId,omitempty" json:"requestId,omitempty"`

	// Format Requested response format. If not set, the Accept-Header is used. If both are missing application/xml is used
	Format *Verb5ParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// JsonpCallback Requests the JSON response data is wrapped into a JavaScript function with that name. String not longer than 1024.
	JsonpCallback *string `form:"jsonpCallback,omitempty" json:"jsonpCallback,omitempty"`

	// Lang The language of the journey planer. String not longer than 5.
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`

	// DateB Sets the event period start date.
	//
	// Since version: 1.0
	DateB *string `form:"dateB,omitempty" json:"dateB,omitempty"`

	// DateE Sets the event period end date.
	//
	// Since version: 1.0
	DateE *string `form:"dateE,omitempty" json:"dateE,omitempty"`

	// TimeB Sets the event period start time.
	//
	// Since version: 1.0
	TimeB *string `form:"timeB,omitempty" json:"timeB,omitempty"`

	// TimeE Sets the event period end time.
	//
	// Since version: 1.0
	TimeE *string `form:"timeE,omitempty" json:"timeE,omitempty"`

	// Weekdays Bitmask for validity of HIM messages based on weekdays. Each character represents a weekday starting on monday.
	//
	// Since version: 2.4
	Weekdays *string `form:"weekdays,omitempty" json:"weekdays,omitempty"`

	// HimIds List of HIM message IDs seperated by comma. String not longer than 1024.
	//
	// Since version: 1.0
	HimIds *string `form:"himIds,omitempty" json:"himIds,omitempty"`

	// HierarchicalView Return parent messages with childs.
	//
	// Since version: 2.8.1
	HierarchicalView *Verb5ParamsHierarchicalView `form:"hierarchicalView,omitempty" json:"hierarchicalView,omitempty"`

	// Operators List of operators seperated by comma. String not longer than 1024.
	//
	// Since version: 1.0
	Operators *string `form:"operators,omitempty" json:"operators,omitempty"`

	// Categories List of train categories seperated by comma. String not longer than 1024.
	//
	// Since version: 1.0
	Categories *string `form:"categories,omitempty" json:"categories,omitempty"`

	// Channels List of channels seperated by comma. String not longer than 1024.
	//
	// Since version: 1.0
	Channels *string `form:"channels,omitempty" json:"channels,omitempty"`

	// Companies List of companies separated by comma. To exclude a company, prepend the value with '!' String not longer than 1024.
	//
	// Since version: 1.0
	Companies *string `form:"companies,omitempty" json:"companies,omitempty"`

	// Lines Only HIM messages for the given line are part of the result. To filter multiple lines, separate the codes by comma. String not longer than 1024.
	//
	// Since version: 2.4
	Lines *string `form:"lines,omitempty" json:"lines,omitempty"`

	// Lineids Only HIM messages for the given line (identified by its line ID) are part of the result. To filter multiple lines, separate the line IDs by comma. String not longer than 1024.
	//
	// Since version: 2.11
	Lineids *string `form:"lineids,omitempty" json:"lineids,omitempty"`

	// Stations List of (external) station ids to be filtered for seperated by comma. String not longer than 1024.
	//
	// Since version: 2.4
	Stations *string `form:"stations,omitempty" json:"stations,omitempty"`

	// Fromstation Filter messages by line segment starting at this station given as (external) station id. String not longer than 512.
	//
	// Since version: 2.4
	Fromstation *string `form:"fromstation,omitempty" json:"fromstation,omitempty"`

	// Tostation Filter messages by line segment travelling in direction of this station given as (external) station id. String not longer than 512.
	//
	// Since version: 2.4
	Tostation *string `form:"tostation,omitempty" json:"tostation,omitempty"`

	// Bothways If enabled, messages in both directions - from 'fromstation' to 'tostation' as well as from 'tostation' to 'fromstation' are returned
	//
	// Since version: 2.4
	Bothways *Verb5ParamsBothways `form:"bothways,omitempty" json:"bothways,omitempty"`

	// Trainnames List of train name to be filtered for seperated by comma. String not longer than 1024.
	//
	// Since version: 2.4
	Trainnames *string `form:"trainnames,omitempty" json:"trainnames,omitempty"`

	// Metas List of predefined filters seperated by comma. String not longer than 512.
	//
	// Since version: 2.4
	Metas *string `form:"metas,omitempty" json:"metas,omitempty"`

	// Himcategory HIM category, e.g. Works and/or Disturbance. Value depends on your HAFAS server data. String not longer than 512.
	//
	// Since version: 1.23.9
	Himcategory *string `form:"himcategory,omitempty" json:"himcategory,omitempty"`

	// Himtags HIM Tags. Value depends on your HAFAS server data. String not longer than 1024.
	//
	// Since version: 2.10
	Himtags *string `form:"himtags,omitempty" json:"himtags,omitempty"`

	// Regions Filter for HIM messages based on regions defined in HAFAS raw data. Seperated by comma. Available regions can be retrieved by /datainfo service. String not longer than 1024.
	//
	// Since version: 2.16
	Regions *string `form:"regions,omitempty" json:"regions,omitempty"`

	// Himtext Filter for HIM messages containing the given free text message seperated by comma. String not longer than 1024.
	//
	// Since version: 2.4
	Himtext *string `form:"himtext,omitempty" json:"himtext,omitempty"`

	// Himtexttags Return HIM texts having this text tag(s) only. Multiple values are separated by comma. Note: HIM text tags differ from HIM tags. String not longer than 1024.
	//
	// Since version: 2.16
	Himtexttags *string `form:"himtexttags,omitempty" json:"himtexttags,omitempty"`

	// Exthimtext Extended filter based on tags and and corresponding localized text fragments. String not longer than 1024.
	//
	// Since version: 2.4
	Exthimtext *string `form:"exthimtext,omitempty" json:"exthimtext,omitempty"`

	// Additionalfields List of additional fields and values to be filtered for. String not longer than 1024.
	//
	// Since version: 2.22
	Additionalfields *string `form:"additionalfields,omitempty" json:"additionalfields,omitempty"`

	// ExtInfo Filter for HIM messages based on external ids and id sources. Different items are seperated by comma. Value seperated by pipe symbol. To negate put ! in front of the item. String not longer than 8096.
	//
	// Since version: 2.38
	ExtInfo *string `form:"extInfo,omitempty" json:"extInfo,omitempty"`

	// Poly Enables/disables returning of geo information for affected edges and regions if available and enabled in the backend.
	//
	// Since version: 1.23.12
	Poly *Verb5ParamsPoly `form:"poly,omitempty" json:"poly,omitempty"`

	// Searchmode HIM search mode.
	//
	// Since version: 1.0
	Searchmode *Verb5ParamsSearchmode `form:"searchmode,omitempty" json:"searchmode,omitempty"`

	// AffectedJourneyMode Define how to return affected journeys
	//
	// Since version: 2.5
	AffectedJourneyMode *Verb5ParamsAffectedJourneyMode `form:"affectedJourneyMode,omitempty" json:"affectedJourneyMode,omitempty"`

	// AffectedJourneyStopMode Define how to return stops of affected journeys
	//
	// Since version: 2.5
	AffectedJourneyStopMode *Verb5ParamsAffectedJourneyStopMode `form:"affectedJourneyStopMode,omitempty" json:"affectedJourneyStopMode,omitempty"`

	// OrderBy Define the Order the returned messages by fields and directions. Multiple, comma separated entries are supported Range: EVT_BEG_ASC,EVT_BEG_DESC,EVT_END_ASC,EVT_END_DESC,HID_ASC,HID_DESC,LMOD_ASC,LMOD_DESC,PRIO_ASC,PRIO_DESC
	//
	// Since version: 2.4.1
	OrderBy *string `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Minprio Filter for HIM messages having at least this priority. Minimum of 0.
	//
	// Since version: 2.4
	Minprio *int `form:"minprio,omitempty" json:"minprio,omitempty"`

	// Maxprio Filter for HIM messages having this priority as maximum. Minimum of 0.
	//
	// Since version: 2.4
	Maxprio *int `form:"maxprio,omitempty" json:"maxprio,omitempty"`

	// LlLat Lower left latitude of bounding box.
	//
	// Since version: 2.24.0
	LlLat *float32 `form:"llLat,omitempty" json:"llLat,omitempty"`

	// LlLon Lower left longitude of bounding box.
	//
	// Since version: 2.24.0
	LlLon *float32 `form:"llLon,omitempty" json:"llLon,omitempty"`

	// UrLat Upper right latitude of bounding box.
	//
	// Since version: 2.24.0
	UrLat *float32 `form:"urLat,omitempty" json:"urLat,omitempty"`

	// UrLon Upper right longitude of bounding box.
	//
	// Since version: 2.24.0
	UrLon *float32 `form:"urLon,omitempty" json:"urLon,omitempty"`
}

// Verb5ParamsFormat defines parameters for Verb5.
type Verb5ParamsFormat string

// Verb5ParamsHierarchicalView defines parameters for Verb5.
type Verb5ParamsHierarchicalView string

// Verb5ParamsBothways defines parameters for Verb5.
type Verb5ParamsBothways string

// Verb5ParamsPoly defines parameters for Verb5.
type Verb5ParamsPoly string

// Verb5ParamsSearchmode defines parameters for Verb5.
type Verb5ParamsSearchmode string

// Verb5ParamsAffectedJourneyMode defines parameters for Verb5.
type Verb5ParamsAffectedJourneyMode string

// Verb5ParamsAffectedJourneyStopMode defines parameters for Verb5.
type Verb5ParamsAffectedJourneyStopMode string

// Verb6Params defines parameters for Verb6.
type Verb6Params struct {
	// RequestId Request ID for identifying the request. String not longer than 2048.
	RequestId *string `form:"requestId,omitempty" json:"requestId,omitempty"`

	// Format Requested response format. If not set, the Accept-Header is used. If both are missing application/xml is used
	Format *Verb6ParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// JsonpCallback Requests the JSON response data is wrapped into a JavaScript function with that name. String not longer than 1024.
	JsonpCallback *string `form:"jsonpCallback,omitempty" json:"jsonpCallback,omitempty"`

	// Lang The language of the journey planer. String not longer than 5.
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`

	// Id Specifies the internal journey id of the journey shall be retrieved. Maximum length 512. String not longer than 512.
	//
	// Since version: 1.0
	Id string `form:"id" json:"id"`

	// Date Day of operation
	//
	// Since version: 1.0
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// Poly Enables/disables the calculation of the polyline for each leg of the trip except any GIS route.
	//
	// Since version: 1.11
	Poly *Verb6ParamsPoly `form:"poly,omitempty" json:"poly,omitempty"`

	// PolyEnc Defines encoding of the returned polyline. Possible values are N (no encoding / compression), DLT (delta to the previous coordinate), GPA (Google encoded polyline format) defaults to N. Not all option might be available in your installation.
	//
	// Since version: 1.11
	PolyEnc *Verb6ParamsPolyEnc `form:"polyEnc,omitempty" json:"polyEnc,omitempty"`

	// ShowPassingPoints Enables/disables the return of stops having no alighting and no boarding in its passlist for each leg of the trip.
	//
	// Since version: 1.0
	ShowPassingPoints *Verb6ParamsShowPassingPoints `form:"showPassingPoints,omitempty" json:"showPassingPoints,omitempty"`

	// RtMode Set the realtime mode to be used.
	//
	// Since version: 1.0
	RtMode *Verb6ParamsRtMode `form:"rtMode,omitempty" json:"rtMode,omitempty"`

	// FromId Specifies the station/stop ID the partial itinerary shall start from. String not longer than 512.
	//
	// Since version: 2.3
	FromId *string `form:"fromId,omitempty" json:"fromId,omitempty"`

	// FromIdx Specifies the station/stop index the partial itinerary shall start from. Minimum of 0.
	//
	// Since version: 2.3
	FromIdx *int `form:"fromIdx,omitempty" json:"fromIdx,omitempty"`

	// ToId Specifies the station/stop ID the partial itinerary shall end at. String not longer than 512.
	//
	// Since version: 2.3
	ToId *string `form:"toId,omitempty" json:"toId,omitempty"`

	// ToIdx Specifies the station/stop index the partial itinerary shall end at. Minimum of 0.
	//
	// Since version: 2.3
	ToIdx *int `form:"toIdx,omitempty" json:"toIdx,omitempty"`

	// Baim Enables/disables BAIM search and response.
	//
	// Since version: 2.7.3
	Baim *Verb6ParamsBaim `form:"baim,omitempty" json:"baim,omitempty"`
}

// Verb6ParamsFormat defines parameters for Verb6.
type Verb6ParamsFormat string

// Verb6ParamsPoly defines parameters for Verb6.
type Verb6ParamsPoly string

// Verb6ParamsPolyEnc defines parameters for Verb6.
type Verb6ParamsPolyEnc string

// Verb6ParamsShowPassingPoints defines parameters for Verb6.
type Verb6ParamsShowPassingPoints string

// Verb6ParamsRtMode defines parameters for Verb6.
type Verb6ParamsRtMode string

// Verb6ParamsBaim defines parameters for Verb6.
type Verb6ParamsBaim string

// Verb7Params defines parameters for Verb7.
type Verb7Params struct {
	// RequestId Request ID for identifying the request. String not longer than 2048.
	RequestId *string `form:"requestId,omitempty" json:"requestId,omitempty"`

	// Format Requested response format. If not set, the Accept-Header is used. If both are missing application/xml is used
	Format *Verb7ParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// JsonpCallback Requests the JSON response data is wrapped into a JavaScript function with that name. String not longer than 1024.
	JsonpCallback *string `form:"jsonpCallback,omitempty" json:"jsonpCallback,omitempty"`

	// Lang The language of the journey planer. String not longer than 5.
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`

	// LlLat Lower left latitude of bounding box.
	//
	// Since version: 1.0
	LlLat float32 `form:"llLat" json:"llLat"`

	// LlLon Lower left longitude of bounding box.
	//
	// Since version: 1.0
	LlLon float32 `form:"llLon" json:"llLon"`

	// UrLat Upper right latitude of bounding box.
	//
	// Since version: 1.0
	UrLat float32 `form:"urLat" json:"urLat"`

	// UrLon Upper right longitude of bounding box.
	//
	// Since version: 1.0
	UrLon float32 `form:"urLon" json:"urLon"`

	// Operators Filter for operators. To filter multiple operators, separate the codes by comma. String not longer than 8096.
	//
	// Since version: 1.0
	Operators *string `form:"operators,omitempty" json:"operators,omitempty"`

	// Products Decimal value defining the product classes to be included in the search. It represents a bitmask combining bit number of a product as defined in the HAFAS raw data. Values are retrievable by <<service_datainfo,Data Information service>>. Minimum of 0.
	//
	// Since version: 1.0
	Products *int `form:"products,omitempty" json:"products,omitempty"`

	// Attributes Filter trips by one or more attribute codes of a journey. Multiple attribute codes are separated by comma. If the attribute should not be part of the be trip, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.0
	Attributes *string `form:"attributes,omitempty" json:"attributes,omitempty"`

	// Jid Filter journeys by one or more journey id. Multiple journey ids are separated by comma. String not longer than 1024.
	//
	// Since version: 1.0
	Jid *string `form:"jid,omitempty" json:"jid,omitempty"`

	// Lines Only journeys running the given line are part of the result. To filter multiple lines, separate the codes by comma. String not longer than 1024.
	//
	// Since version: 1.0
	Lines *string `form:"lines,omitempty" json:"lines,omitempty"`

	// Infotexts Filter journeys by one or more custom infotext filters. Multiple infotexts are separated by comma. If the infotext should not be part of the be trip, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.0
	Infotexts *string `form:"infotexts,omitempty" json:"infotexts,omitempty"`

	// MaxJny Maximum number of journeys in response. Minimum of 0. Range: 1-1000
	//
	// Since version: 1.0
	MaxJny *int `form:"maxJny,omitempty" json:"maxJny,omitempty"`

	// PeriodSize Size of interval journey positions should be retrieved in milliseonds. Minimum of 0.
	//
	// Since version: 2.24
	PeriodSize *int `form:"periodSize,omitempty" json:"periodSize,omitempty"`

	// PeriodStep Size of interval steps. Minimum of 0.
	//
	// Since version: 2.24
	PeriodStep *int `form:"periodStep,omitempty" json:"periodStep,omitempty"`

	// Date Day of operation.
	//
	// Since version: 1.0
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// Time Time the service operates according to scheduled data. If not provided, the whole day is taken into account.
	//
	// Since version: 1.0
	Time *string `form:"time,omitempty" json:"time,omitempty"`

	// PositionMode Mode the used for position calculation. REPORT_ONLY: Only get back reported positions; CALC_REPORT: Use reported position if available, calculate if not; CALC: Calculate all positions; Default REPORT_ONLY
	//
	// Since version: 1.0
	PositionMode *Verb7ParamsPositionMode `form:"positionMode,omitempty" json:"positionMode,omitempty"`
}

// Verb7ParamsFormat defines parameters for Verb7.
type Verb7ParamsFormat string

// Verb7ParamsPositionMode defines parameters for Verb7.
type Verb7ParamsPositionMode string

// Verb8Params defines parameters for Verb8.
type Verb8Params struct {
	// RequestId Request ID for identifying the request. String not longer than 2048.
	RequestId *string `form:"requestId,omitempty" json:"requestId,omitempty"`

	// Format Requested response format. If not set, the Accept-Header is used. If both are missing application/xml is used
	Format *Verb8ParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// JsonpCallback Requests the JSON response data is wrapped into a JavaScript function with that name. String not longer than 1024.
	JsonpCallback *string `form:"jsonpCallback,omitempty" json:"jsonpCallback,omitempty"`

	// Lang The language of the journey planer. String not longer than 5.
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`

	// Input Search for that token. String not longer than 512.
	//
	// Since version: 1.0
	Input string `form:"input" json:"input"`

	// MaxNo Maximum number of returned stops. Range: 1-1000
	//
	// Since version: 1.0
	MaxNo *int `form:"maxNo,omitempty" json:"maxNo,omitempty"`

	// Type Type filter for location types.
	//
	// Since version: 1.20
	Type *Verb8ParamsType `form:"type,omitempty" json:"type,omitempty"`

	// LocationSelectionMode Selection mode for locations.
	//
	// Since version: 1.20
	LocationSelectionMode *Verb8ParamsLocationSelectionMode `form:"locationSelectionMode,omitempty" json:"locationSelectionMode,omitempty"`

	// WithEquivalentLocations Return equivalent locations.
	//
	// Since version: 2.33
	WithEquivalentLocations *Verb8ParamsWithEquivalentLocations `form:"withEquivalentLocations,omitempty" json:"withEquivalentLocations,omitempty"`

	// RestrictSelection Restrict allowed stations.
	//
	// Since version: 2.31
	RestrictSelection *Verb8ParamsRestrictSelection `form:"restrictSelection,omitempty" json:"restrictSelection,omitempty"`

	// Products Decimal value defining the product classes to be included in the search. It represents a bitmask combining bit number of a product as defined in the HAFAS raw data. Values are retrievable by <<service_datainfo,Data Information service>>. Minimum of 0.
	//
	// Since version: 1.15
	Products *int `form:"products,omitempty" json:"products,omitempty"`

	// WithProducts Return locations with products.
	//
	// Since version: 2.28
	WithProducts *Verb8ParamsWithProducts `form:"withProducts,omitempty" json:"withProducts,omitempty"`

	// ProductRepresentatives If activated, only one representative of a location product per category is returned.
	//
	// Since version: 2.28
	ProductRepresentatives *Verb8ParamsProductRepresentatives `form:"productRepresentatives,omitempty" json:"productRepresentatives,omitempty"`

	// CoordLat Latitude of centre coordinate.
	//
	// Since version: 1.20
	CoordLat *float32 `form:"coordLat,omitempty" json:"coordLat,omitempty"`

	// CoordLong Longitude of centre coordinate.
	//
	// Since version: 1.20
	CoordLong *float32 `form:"coordLong,omitempty" json:"coordLong,omitempty"`

	// R Search radius in meter around the given coordinate if any. Minimum of 1.
	//
	// Since version: 1.20
	R *int `form:"r,omitempty" json:"r,omitempty"`

	// RefineId In case of an refinable location, this value takes the ID of the refinable one of a previous result. String not longer than 512.
	//
	// Since version: 1.0
	RefineId *string `form:"refineId,omitempty" json:"refineId,omitempty"`

	// Meta Filter by a predefined meta filter. If the rules of the predefined filter should not be negated, put ! in front of it. Multiple values are separated by comma if definded for POI filtering. String not longer than 512.
	//
	// Since version: 1.0
	Meta *string `form:"meta,omitempty" json:"meta,omitempty"`

	// Stations Filter for stations. Matches if the given value is prefix of any station ID. Multiple values are separated by comma. String not longer than 4096.
	//
	// Since version: 1.0
	Stations *string `form:"stations,omitempty" json:"stations,omitempty"`

	// Sattributes Filter locations by one or more attribute codes. Multiple attribute codes are separated by comma. If the attribute should not be part of the be location data, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.0
	Sattributes *string `form:"sattributes,omitempty" json:"sattributes,omitempty"`

	// Sinfotexts Filter locations by one or more station infotext codes and values. Parameter structure is code|value. Multiple attribute codes are separated by comma. String not longer than 1024.
	//
	// Since version: 2.24
	Sinfotexts *string `form:"sinfotexts,omitempty" json:"sinfotexts,omitempty"`

	// FilterMode Filter modes for nearby searches.
	//
	// Since version: 2.7
	FilterMode *Verb8ParamsFilterMode `form:"filterMode,omitempty" json:"filterMode,omitempty"`

	// PoolId Filter locations by pool id (also known as Pool UIC code). Multiple values are separated by comma. To negate put ! in front of the value. String not longer than 8096.
	//
	// Since version: 2.26
	PoolId *string `form:"poolId,omitempty" json:"poolId,omitempty"`
}

// Verb8ParamsFormat defines parameters for Verb8.
type Verb8ParamsFormat string

// Verb8ParamsType defines parameters for Verb8.
type Verb8ParamsType string

// Verb8ParamsLocationSelectionMode defines parameters for Verb8.
type Verb8ParamsLocationSelectionMode string

// Verb8ParamsWithEquivalentLocations defines parameters for Verb8.
type Verb8ParamsWithEquivalentLocations string

// Verb8ParamsRestrictSelection defines parameters for Verb8.
type Verb8ParamsRestrictSelection string

// Verb8ParamsWithProducts defines parameters for Verb8.
type Verb8ParamsWithProducts string

// Verb8ParamsProductRepresentatives defines parameters for Verb8.
type Verb8ParamsProductRepresentatives string

// Verb8ParamsFilterMode defines parameters for Verb8.
type Verb8ParamsFilterMode string

// Verb9Params defines parameters for Verb9.
type Verb9Params struct {
	// RequestId Request ID for identifying the request. String not longer than 2048.
	RequestId *string `form:"requestId,omitempty" json:"requestId,omitempty"`

	// Format Requested response format. If not set, the Accept-Header is used. If both are missing application/xml is used
	Format *Verb9ParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// JsonpCallback Requests the JSON response data is wrapped into a JavaScript function with that name. String not longer than 1024.
	JsonpCallback *string `form:"jsonpCallback,omitempty" json:"jsonpCallback,omitempty"`

	// Lang The language of the journey planer. String not longer than 5.
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`

	// OriginCoordLat Latitude of centre coordinate.
	//
	// Since version: 1.0
	OriginCoordLat float32 `form:"originCoordLat" json:"originCoordLat"`

	// OriginCoordLong Longitude of centre coordinate.
	//
	// Since version: 1.0
	OriginCoordLong float32 `form:"originCoordLong" json:"originCoordLong"`

	// R Search radius in meter around the given coordinate. Minimum of 1.
	//
	// Since version: 1.0
	R *int `form:"r,omitempty" json:"r,omitempty"`

	// MaxNo Maximum number of returned stops. Minimum of 0. Range: 1-1000
	//
	// Since version: 1.0
	MaxNo *int `form:"maxNo,omitempty" json:"maxNo,omitempty"`

	// Type Type filter for location types.
	//
	// Since version: 1.0
	Type *Verb9ParamsType `form:"type,omitempty" json:"type,omitempty"`

	// LocationSelectionMode Selection mode for locations.
	//
	// Since version: 1.20
	LocationSelectionMode *Verb9ParamsLocationSelectionMode `form:"locationSelectionMode,omitempty" json:"locationSelectionMode,omitempty"`

	// Products Decimal value defining the product classes to be included in the search. It represents a bitmask combining bit number of a product as defined in the HAFAS raw data. Values are retrievable by <<service_datainfo,Data Information service>>. Minimum of 0.
	//
	// Since version: 1.15
	Products *int `form:"products,omitempty" json:"products,omitempty"`

	// Meta Filter by a predefined meta filter. If the rules of the predefined filter should not be negated, put ! in front of it. Multiple values are separated by comma if definded for POI filtering. String not longer than 512.
	//
	// Since version: 1.0
	Meta *string `form:"meta,omitempty" json:"meta,omitempty"`

	// Sattributes Filter locations by one or more attribute codes. Multiple attribute codes are separated by comma. If the attribute should not be part of the be location data, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.0
	Sattributes *string `form:"sattributes,omitempty" json:"sattributes,omitempty"`

	// Sinfotexts Filter locations by one or more station infotext codes and values. Multiple attribute codes are separated by comma the value by pipe |. String not longer than 1024.
	//
	// Since version: 1.0
	Sinfotexts *string `form:"sinfotexts,omitempty" json:"sinfotexts,omitempty"`

	// PoolId Filter locations by pool id (also known as Pool UIC code). Multiple values are separated by comma. To negate put ! in front of the value. String not longer than 8096.
	//
	// Since version: 2.26
	PoolId *string `form:"poolId,omitempty" json:"poolId,omitempty"`

	// Date Incorporate date. Represented in the format YYYY-MM-DD.
	//
	// Since version: 2.39
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// Time Incorporate time. Represented in the format hh:mm[:ss] in 24h nomenclature. Seconds will be ignored for requests.
	//
	// Since version: 2.39
	Time *string `form:"time,omitempty" json:"time,omitempty"`

	// Zoom Retrieve stops most relevant to this map zoom level. Range: 0-21
	//
	// Since version: 2.39
	Zoom *int `form:"zoom,omitempty" json:"zoom,omitempty"`

	// PoiCategories Filter locations by POI types. Multiple attribute codes are separated by comma. If the attribute should not be part of the be location data, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 2.42
	PoiCategories *string `form:"poiCategories,omitempty" json:"poiCategories,omitempty"`
}

// Verb9ParamsFormat defines parameters for Verb9.
type Verb9ParamsFormat string

// Verb9ParamsType defines parameters for Verb9.
type Verb9ParamsType string

// Verb9ParamsLocationSelectionMode defines parameters for Verb9.
type Verb9ParamsLocationSelectionMode string

// Verb10Params defines parameters for Verb10.
type Verb10Params struct {
	// RequestId Request ID for identifying the request. String not longer than 2048.
	RequestId *string `form:"requestId,omitempty" json:"requestId,omitempty"`

	// Format Requested response format. If not set, the Accept-Header is used. If both are missing application/xml is used
	Format *Verb10ParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// JsonpCallback Requests the JSON response data is wrapped into a JavaScript function with that name. String not longer than 1024.
	JsonpCallback *string `form:"jsonpCallback,omitempty" json:"jsonpCallback,omitempty"`

	// Lang The language of the journey planer. String not longer than 5.
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`

	// Ctx Specifies the reconstruction context. String not longer than 32768.
	//
	// Since version: 1.12
	Ctx string `form:"ctx" json:"ctx"`

	// Poly Enables/disables the calculation of the polyline for each leg of the trip except any GIS route.
	//
	// Since version: 1.12
	Poly *Verb10ParamsPoly `form:"poly,omitempty" json:"poly,omitempty"`

	// PolyEnc Defines encoding of the returned polyline. Possible values are N (no encoding / compression), DLT (delta to the previous coordinate), GPA (Google encoded polyline format) defaults to N. Not all option might be available in your installation.
	//
	// Since version: 1.12
	PolyEnc *Verb10ParamsPolyEnc `form:"polyEnc,omitempty" json:"polyEnc,omitempty"`

	// Date Sets the start date for which the departures shall be retrieved. Represented in the format YYYY-MM-DD.
	//
	// Since version: 1.12
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// UseCombinedComparison Compare based on combined output name - false: Compare parameters (category, line, train number) individually
	UseCombinedComparison *Verb10ParamsUseCombinedComparison `form:"useCombinedComparison,omitempty" json:"useCombinedComparison,omitempty"`

	// AcceptGaps Accept an incomplete description of the connection (with gaps) i.e. missing walks/transfers
	//
	// Since version: 2.6.2
	AcceptGaps *Verb10ParamsAcceptGaps `form:"acceptGaps,omitempty" json:"acceptGaps,omitempty"`

	// AllowDummySections Allow a partial reconstruction that will not lead to a reconstruction failure if sections are not reconstructable. Instead, for theses inconstructable sections, dummy sections will be created in the result.
	//
	// Since version: 2.11.0
	AllowDummySections *Verb10ParamsAllowDummySections `form:"allowDummySections,omitempty" json:"allowDummySections,omitempty"`

	// FlagAllNonReachable Should all non-reachable journeys be flagged (true), or only the first one encountered?
	//
	// Since version: 2.6.2
	FlagAllNonReachable *Verb10ParamsFlagAllNonReachable `form:"flagAllNonReachable,omitempty" json:"flagAllNonReachable,omitempty"`

	// MatchCatStrict Should the category (Gattung) match exactly? Only applicable if useCombinedComparison is false
	//
	// Since version: 2.6.2
	MatchCatStrict *Verb10ParamsMatchCatStrict `form:"matchCatStrict,omitempty" json:"matchCatStrict,omitempty"`

	// MatchIdNonBlank Should the train identifier (Zugbezeichner) without whitespace match?
	//
	// Since version: 2.6.2
	MatchIdNonBlank *Verb10ParamsMatchIdNonBlank `form:"matchIdNonBlank,omitempty" json:"matchIdNonBlank,omitempty"`

	// MatchIdStrict Should the train identifier (Zugbezeichner) match exactly?
	//
	// Since version: 2.6.2
	MatchIdStrict *Verb10ParamsMatchIdStrict `form:"matchIdStrict,omitempty" json:"matchIdStrict,omitempty"`

	// MatchNumStrict Should the train number (Zugnummer) match exactly? Only applicable if useCombinedComparison is false
	//
	// Since version: 2.6.2
	MatchNumStrict *Verb10ParamsMatchNumStrict `form:"matchNumStrict,omitempty" json:"matchNumStrict,omitempty"`

	// MatchRtType Should the realtime type that journeys are based on (e.g. SOLL, IST, additional, deviation, ...) be considered?
	//
	// Since version: 2.6.2
	MatchRtType *Verb10ParamsMatchRtType `form:"matchRtType,omitempty" json:"matchRtType,omitempty"`

	// EnableRtFullSearch By default, the reconstruction request makes one attempt for each journey within the scheduled data. However, the scheduled data may not necessarily reflect basic realtime properties of the journeys therein. In such a case, one may enable a two-step approach which we call "full search", i.e. search for matching journeys in the scheduled data in a first step. If this fails, then search for matching journeys in the realtime data.
	//
	// Since version: 2.15
	EnableRtFullSearch *Verb10ParamsEnableRtFullSearch `form:"enableRtFullSearch,omitempty" json:"enableRtFullSearch,omitempty"`

	// EnableReplacements If set to true replaces cancelled journeys with their replacement journeys if possible.
	//
	// Since version: 2.21.0
	EnableReplacements *Verb10ParamsEnableReplacements `form:"enableReplacements,omitempty" json:"enableReplacements,omitempty"`

	// ArrL Lower deviation in minutes within interval [0, 720] indicating "how much earlier than original arrival" Range: 0-720
	//
	// Since version: 2.6.2
	ArrL *int `form:"arrL,omitempty" json:"arrL,omitempty"`

	// ArrU Upper deviation in minutes within interval [0, 720] indicating "how much later than original arrival" Range: 0-720
	//
	// Since version: 2.6.2
	ArrU *int `form:"arrU,omitempty" json:"arrU,omitempty"`

	// DepL Lower deviation in minutes within interval [0, 720] indicating "how much earlier than original departure" Range: 0-720
	//
	// Since version: 2.6.2
	DepL *int `form:"depL,omitempty" json:"depL,omitempty"`

	// DepU Upper deviation in minutes within interval [0, 720] indicating "how much later than original departure" Range: 0-720
	//
	// Since version: 2.6.2
	DepU *int `form:"depU,omitempty" json:"depU,omitempty"`

	// Passlist Enables/disables the return of the passlist for each leg of the trip.
	//
	// Since version: 1.12
	Passlist *Verb10ParamsPasslist `form:"passlist,omitempty" json:"passlist,omitempty"`

	// ShowPassingPoints Enables/disables the return of stops having no alighting and boarding in its passlist for each leg of the trip. Needs passlist parameter enabled.
	//
	// Since version: 1.12
	ShowPassingPoints *Verb10ParamsShowPassingPoints `form:"showPassingPoints,omitempty" json:"showPassingPoints,omitempty"`

	// RtMode Set the realtime mode to be used.
	//
	// Since version: 2.10.0
	RtMode *Verb10ParamsRtMode `form:"rtMode,omitempty" json:"rtMode,omitempty"`

	// Baim Enables/disables BAIM.
	//
	// Since version: 2.39
	Baim *Verb10ParamsBaim `form:"baim,omitempty" json:"baim,omitempty"`

	// Eco Only supported if legacy environmental calculator is used.
	//
	// Deprecated. Enables/disables eco value calculation.
	//
	// Since version: 1.23.9
	Eco *Verb10ParamsEco `form:"eco,omitempty" json:"eco,omitempty"`

	// EcoCmp Only supported if legacy environmental calculator is used.
	//
	// Deprecated. Enables/disables eco comparison.
	//
	// Since version: 1.23.9
	EcoCmp *Verb10ParamsEcoCmp `form:"ecoCmp,omitempty" json:"ecoCmp,omitempty"`

	// EcoParams Provide additional eco parameters. Values vary. String not longer than 1024.
	//
	// Since version: 1.23.9
	EcoParams *string `form:"ecoParams,omitempty" json:"ecoParams,omitempty"`

	// Tariff Enables/disables the output of tariff data. The default is configurable via provisioning.
	//
	// Since version: 2.7
	Tariff *Verb10ParamsTariff `form:"tariff,omitempty" json:"tariff,omitempty"`

	// TrafficMessages Enables/disables the output of traffic messages. The default is configurable via provisioning.
	//
	// Since version: 2.7
	TrafficMessages *Verb10ParamsTrafficMessages `form:"trafficMessages,omitempty" json:"trafficMessages,omitempty"`

	// TravellerProfileData Traveller profile data. Structure depends on set up. String not longer than 32768.
	//
	// Since version: 2.15
	TravellerProfileData *string `form:"travellerProfileData,omitempty" json:"travellerProfileData,omitempty"`

	// WithJourneyBoundaryPoints Enables/disables the return of journey boundary stops at public transport legs.
	//
	// Since version: 2.24
	WithJourneyBoundaryPoints *Verb10ParamsWithJourneyBoundaryPoints `form:"withJourneyBoundaryPoints,omitempty" json:"withJourneyBoundaryPoints,omitempty"`

	// Freq Sets the frequency interval length for the search of journey alternatives in minutes. Using a value of 0 results in the suppression of the search for alternatives. Minimum of 0.
	//
	// Since version: 2.35
	Freq *int `form:"freq,omitempty" json:"freq,omitempty"`
}

// Verb10ParamsFormat defines parameters for Verb10.
type Verb10ParamsFormat string

// Verb10ParamsPoly defines parameters for Verb10.
type Verb10ParamsPoly string

// Verb10ParamsPolyEnc defines parameters for Verb10.
type Verb10ParamsPolyEnc string

// Verb10ParamsUseCombinedComparison defines parameters for Verb10.
type Verb10ParamsUseCombinedComparison string

// Verb10ParamsAcceptGaps defines parameters for Verb10.
type Verb10ParamsAcceptGaps string

// Verb10ParamsAllowDummySections defines parameters for Verb10.
type Verb10ParamsAllowDummySections string

// Verb10ParamsFlagAllNonReachable defines parameters for Verb10.
type Verb10ParamsFlagAllNonReachable string

// Verb10ParamsMatchCatStrict defines parameters for Verb10.
type Verb10ParamsMatchCatStrict string

// Verb10ParamsMatchIdNonBlank defines parameters for Verb10.
type Verb10ParamsMatchIdNonBlank string

// Verb10ParamsMatchIdStrict defines parameters for Verb10.
type Verb10ParamsMatchIdStrict string

// Verb10ParamsMatchNumStrict defines parameters for Verb10.
type Verb10ParamsMatchNumStrict string

// Verb10ParamsMatchRtType defines parameters for Verb10.
type Verb10ParamsMatchRtType string

// Verb10ParamsEnableRtFullSearch defines parameters for Verb10.
type Verb10ParamsEnableRtFullSearch string

// Verb10ParamsEnableReplacements defines parameters for Verb10.
type Verb10ParamsEnableReplacements string

// Verb10ParamsPasslist defines parameters for Verb10.
type Verb10ParamsPasslist string

// Verb10ParamsShowPassingPoints defines parameters for Verb10.
type Verb10ParamsShowPassingPoints string

// Verb10ParamsRtMode defines parameters for Verb10.
type Verb10ParamsRtMode string

// Verb10ParamsBaim defines parameters for Verb10.
type Verb10ParamsBaim string

// Verb10ParamsEco defines parameters for Verb10.
type Verb10ParamsEco string

// Verb10ParamsEcoCmp defines parameters for Verb10.
type Verb10ParamsEcoCmp string

// Verb10ParamsTariff defines parameters for Verb10.
type Verb10ParamsTariff string

// Verb10ParamsTrafficMessages defines parameters for Verb10.
type Verb10ParamsTrafficMessages string

// Verb10ParamsWithJourneyBoundaryPoints defines parameters for Verb10.
type Verb10ParamsWithJourneyBoundaryPoints string

// Verb12Params defines parameters for Verb12.
type Verb12Params struct {
	Type Verb12ParamsType `form:"type" json:"type"`
}

// Verb12ParamsType defines parameters for Verb12.
type Verb12ParamsType string

// Verb11Params defines parameters for Verb11.
type Verb11Params struct {
	// RequestId Request ID for identifying the request. String not longer than 2048.
	RequestId *string `form:"requestId,omitempty" json:"requestId,omitempty"`

	// Format Requested response format. If not set, the Accept-Header is used. If both are missing application/xml is used
	Format *Verb11ParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// JsonpCallback Requests the JSON response data is wrapped into a JavaScript function with that name. String not longer than 1024.
	JsonpCallback *string `form:"jsonpCallback,omitempty" json:"jsonpCallback,omitempty"`

	// Lang The language of the journey planer. String not longer than 5.
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`

	// OriginId Specifies the station/stop ID of the origin for the trip.
	// Such ID can be retrieved from the location.name or location.nearbystops services. String not longer than 512.
	//
	// Since version: 1.0
	OriginId *string `form:"originId,omitempty" json:"originId,omitempty"`

	// OriginExtId Deprecated. Please use `originId` as it supports external IDs.
	//
	// Specifies the external station/stop ID of the origin for the trip.
	// Such ID can be retrieved from the location.name or location.nearbystops services. String not longer than 512.
	//
	// Since version: 1.20
	OriginExtId *string `form:"originExtId,omitempty" json:"originExtId,omitempty"`

	// OriginCoordLat Latitude of station/stop coordinate of the trips origin. The coordinate can be retrieved from the location.name or location.nearbystops services.
	//
	// Since version: 1.0
	OriginCoordLat *float32 `form:"originCoordLat,omitempty" json:"originCoordLat,omitempty"`

	// OriginCoordLong Longitude of station/stop coordinate of the trips origin. The coordinate can be retrieved from the location.name or location.nearbystops services.
	//
	// Since version: 1.0
	OriginCoordLong *float32 `form:"originCoordLong,omitempty" json:"originCoordLong,omitempty"`

	// OriginCoordName Name of the trip's origin if coordinate cannot be resolved to an address or poi. String not longer than 512.
	//
	// Since version: 2.13
	OriginCoordName *string `form:"originCoordName,omitempty" json:"originCoordName,omitempty"`

	// OriginCoordType Type of the trip's origin if coordinate cannot be resolved to an address or poi.
	//
	// Since version: 2.30
	OriginCoordType *Verb11ParamsOriginCoordType `form:"originCoordType,omitempty" json:"originCoordType,omitempty"`

	// DestId Specifies the station/stop ID of the destination for the trip.
	// Such ID can be retrieved from the location.name or location.nearbystops services. String not longer than 512.
	//
	// Since version: 1.0
	DestId *string `form:"destId,omitempty" json:"destId,omitempty"`

	// DestExtId Deprecated. Please use `destId` as it supports external IDs.
	//
	// Specifies the external station/stop ID of the destination for the trip.
	// Such ID can be retrieved from the location.name or location.nearbystops services. String not longer than 512.
	//
	// Since version: 1.20
	DestExtId *string `form:"destExtId,omitempty" json:"destExtId,omitempty"`

	// DestCoordLat Latitude of station/stop coordinate of the trips destination. The coordinate can be retrieved from the location.name or location.nearbystops services.
	//
	// Since version: 1.0
	DestCoordLat *float32 `form:"destCoordLat,omitempty" json:"destCoordLat,omitempty"`

	// DestCoordLong Longitude of station/stop coordinate of the trips destination. The coordinate can be retrieved from the location.name or location.nearbystops services.
	//
	// Since version: 1.0
	DestCoordLong *float32 `form:"destCoordLong,omitempty" json:"destCoordLong,omitempty"`

	// DestCoordName Name of the trip's destination if coordinate cannot be resolved to an address or poi. String not longer than 512.
	//
	// Since version: 2.13
	DestCoordName *string `form:"destCoordName,omitempty" json:"destCoordName,omitempty"`

	// DestCoordType Type of the trip's destination if coordinate cannot be resolved to an address or poi.
	//
	// Since version: 2.30
	DestCoordType *Verb11ParamsDestCoordType `form:"destCoordType,omitempty" json:"destCoordType,omitempty"`

	// Via Complex structure to provide multiple via points separated by semicolon. String not longer than 8096.
	//
	// Since version: 1.0
	Via *string `form:"via,omitempty" json:"via,omitempty"`

	// ViaId ID of a station/stop used as a via for the trip. Specifying a via station forces the trip search to look for trips which must pass through this station.
	// Such IDs can be retrieved from the location.name or location.nearbystops services. String not longer than 512.
	//
	// Since version: 1.0
	ViaId *string `form:"viaId,omitempty" json:"viaId,omitempty"`

	// ViaWaitTime Defines the waiting time spent at via station in minutes. Minimum of 0.
	//
	// Since version: 1.0
	ViaWaitTime *int `form:"viaWaitTime,omitempty" json:"viaWaitTime,omitempty"`

	// Avoid Complex structure to provide multiple points to be avoided separated by semicolon. String not longer than 8096.
	//
	// Since version: 1.0
	Avoid *string `form:"avoid,omitempty" json:"avoid,omitempty"`

	// AvoidId ID of a station/stop to be avoided as transfer stop for the trip.
	// Such IDs can be retrieved from the location.name or location.nearbystops services. String not longer than 512.
	//
	// Since version: 1.22.2
	AvoidId *string `form:"avoidId,omitempty" json:"avoidId,omitempty"`

	// ViaGis Complex structure to provide multiple GIS via locations separated by semicolon. String not longer than 8096.
	//
	// Since version: 2.14
	ViaGis *string `form:"viaGis,omitempty" json:"viaGis,omitempty"`

	// ChangeTimePercent Configures the walking speed when changing from one leg of the journey to the next one. It extends the time required for changes by a specified percentage.
	// A value of 200 doubles the change time as initially calculated by the system. Minimum of 0.
	//
	// Since version: 1.0
	ChangeTimePercent *int `form:"changeTimePercent,omitempty" json:"changeTimePercent,omitempty"`

	// MinChangeTime Minimum change time at stop in minutes. Minimum of 0.
	//
	// Since version: 1.0
	MinChangeTime *int `form:"minChangeTime,omitempty" json:"minChangeTime,omitempty"`

	// MaxChangeTime Maximum change time at stop in minutes. Minimum of 0.
	//
	// Since version: 1.20
	MaxChangeTime *int `form:"maxChangeTime,omitempty" json:"maxChangeTime,omitempty"`

	// AddChangeTime This amount of minutes is added to the change time at each stop. Minimum of 0.
	//
	// Since version: 1.0
	AddChangeTime *int `form:"addChangeTime,omitempty" json:"addChangeTime,omitempty"`

	// MaxChange Maximum number of changes. Range: 0-11
	//
	// Since version: 1.0
	MaxChange *int `form:"maxChange,omitempty" json:"maxChange,omitempty"`

	// Date Sets the start date for which the departures shall be retrieved. Represented in the format YYYY-MM-DD.
	//
	// Since version: 1.0
	Date *string `form:"date,omitempty" json:"date,omitempty"`

	// Time Sets the start time for which the departures shall be retrieved. Represented in the format hh:mm[:ss] in 24h nomenclature. Seconds will be ignored for requests.
	//
	// Since version: 1.0
	Time *string `form:"time,omitempty" json:"time,omitempty"`

	// SearchForArrival If set, the date and time parameters specify the arrival time for the trip search instead of the departure time.
	//
	// Since version: 1.0
	SearchForArrival *Verb11ParamsSearchForArrival `form:"searchForArrival,omitempty" json:"searchForArrival,omitempty"`

	// NumF Minimum number of trips after or before the search time, depending on search direction. Sum of numF and numB has to be less or equal 6. The maximum value depends on the actual configuration.
	//
	// Please see the section below about the search algorithm for more details. Range: 1-6
	//
	// Since version: 1.10
	NumF *int `form:"numF,omitempty" json:"numF,omitempty"`

	// NumB Minimum number of trips before or after the search time, depending on search direction. Sum of numF and numB has to be less or equal 6. The maximum value depends on the actual configuration.
	//
	// Please see the section below about the search algorithm for more details. Range: 0-5
	//
	// Since version: 1.10
	NumB *int `form:"numB,omitempty" json:"numB,omitempty"`

	// Context Defines the starting point for the scroll back or forth operation. Use the scrB value from a previous result to scroll backwards in time and use the scrF value to scroll forth. String not longer than 8096.
	//
	// Since version: 1.0
	Context *string `form:"context,omitempty" json:"context,omitempty"`

	// Poly Enables/disables the calculation of the polyline for each leg of the trip except any GIS route.
	//
	// Since version: 1.11
	Poly *Verb11ParamsPoly `form:"poly,omitempty" json:"poly,omitempty"`

	// PolyEnc Defines encoding of the returned polyline. Possible values are N (no encoding / compression), DLT (delta to the previous coordinate), GPA (Google encoded polyline format) defaults to N. Not all option might be available in your installation.
	//
	// Since version: 1.11
	PolyEnc *Verb11ParamsPolyEnc `form:"polyEnc,omitempty" json:"polyEnc,omitempty"`

	// Passlist Enables/disables the return of the passlist for each leg of the trip.
	//
	// Since version: 1.20
	Passlist *Verb11ParamsPasslist `form:"passlist,omitempty" json:"passlist,omitempty"`

	// Products Decimal value defining the product classes to be included in the search. It represents a bitmask combining bit number of a product as defined in the HAFAS raw data. Values are retrievable by <<service_datainfo,Data Information service>>. Minimum of 0.
	//
	// Since version: 1.0
	Products *int `form:"products,omitempty" json:"products,omitempty"`

	// Operators Only trips provided by the given operators are part of the result. To filter multiple operators, separate the codes by comma.
	// If the operator should not be part of the trip, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.12
	Operators *string `form:"operators,omitempty" json:"operators,omitempty"`

	// Categories Only trips provided by the given categories are part of the result. To filter multiple categories, separate the codes by comma.
	// If the category should not be part of the trip, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 2.25
	Categories *string `form:"categories,omitempty" json:"categories,omitempty"`

	// CategoryFlags Only trips matching the given category flags are part of the result. To filter multiple category flags, separate the codes by comma. String not longer than 1024.
	//
	// Since version: 2.35
	CategoryFlags *string `form:"categoryFlags,omitempty" json:"categoryFlags,omitempty"`

	// Attributes Filter trips by one or more attribute codes of a journey. Multiple attribute codes are separated by comma. If the attribute should not be part of the be trip, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.0
	Attributes *string `form:"attributes,omitempty" json:"attributes,omitempty"`

	// Sattributes Filter trips by one or more station attribute codes of a journey. Multiple attribute codes are separated by comma. If the attribute should not be part of the be trip, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.23.7
	Sattributes *string `form:"sattributes,omitempty" json:"sattributes,omitempty"`

	// Fattributes Filter trips by one or more footway attribute codes of a journey. Multiple attribute codes are separated by comma. If the attribute should not be part of the be trip, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 2.7
	Fattributes *string `form:"fattributes,omitempty" json:"fattributes,omitempty"`

	// Lines Only journeys running the given line are part of the result. To filter multiple lines, separate the codes by comma. If the line should not be part of the be trip, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.0
	Lines *string `form:"lines,omitempty" json:"lines,omitempty"`

	// Lineids Only journeys running the given line (identified by its line ID) are part of the result. To filter multiple lines, separate the line IDs by comma. If the line should not be part of the trip, negate it by putting ! in front of it. String not longer than 1024.
	//
	// Since version: 1.0
	Lineids *string `form:"lineids,omitempty" json:"lineids,omitempty"`

	// AvoidPaths Only path not having the given properties will be part of the result. String not longer than 512.
	//
	// Since version: 1.12
	AvoidPaths *string `form:"avoidPaths,omitempty" json:"avoidPaths,omitempty"`

	// OriginWalk Enables/disables using footpaths in the beginning of a trip when searching from an address. String not longer than 1024.
	//
	// Since version: 1.0
	OriginWalk *string `form:"originWalk,omitempty" json:"originWalk,omitempty"`

	// OriginBike Enables/disables using bike routes in the beginning of a trip when searching from an address. String not longer than 1024.
	//
	// Since version: 1.0
	OriginBike *string `form:"originBike,omitempty" json:"originBike,omitempty"`

	// OriginCar Enables/disables using car in the beginning of a trip when searching from an address. String not longer than 1024.
	//
	// Since version: 1.0
	OriginCar *string `form:"originCar,omitempty" json:"originCar,omitempty"`

	// OriginTaxi Enables/disables using taxi rides in the beginning of a trip when searching from an address. String not longer than 1024.
	//
	// Since version: 1.0
	OriginTaxi *string `form:"originTaxi,omitempty" json:"originTaxi,omitempty"`

	// OriginPark Enables/disables using Park and Ride in the beginning of a trip when searching from an address String not longer than 1024.
	//
	// Since version: 1.0
	OriginPark *string `form:"originPark,omitempty" json:"originPark,omitempty"`

	// OriginMeta Enables using one or more predefined individual transport meta profile at the beginning of a trip. The profiles are defined in the HAFAS installation. String not longer than 512.
	//
	// Since version: 1.23.25
	OriginMeta *string `form:"originMeta,omitempty" json:"originMeta,omitempty"`

	// DestWalk Enables/disables using footpaths at the end of a trip when searching to an address. String not longer than 1024.
	//
	// Since version: 1.0
	DestWalk *string `form:"destWalk,omitempty" json:"destWalk,omitempty"`

	// DestBike Enables/disables using bike routes at the end of a trip when searching to an address. String not longer than 1024.
	//
	// Since version: 1.0
	DestBike *string `form:"destBike,omitempty" json:"destBike,omitempty"`

	// DestCar Enables/disables using car routes at the end of a trip when searching to an address. String not longer than 1024.
	//
	// Since version: 1.0
	DestCar *string `form:"destCar,omitempty" json:"destCar,omitempty"`

	// DestTaxi Enables/disables using taxi rides at the end of a trip when searching to an address. String not longer than 1024.
	//
	// Since version: 1.0
	DestTaxi *string `form:"destTaxi,omitempty" json:"destTaxi,omitempty"`

	// DestPark Enables/disables using Park and Ride at the end of a trip when searching to an address. String not longer than 1024.
	//
	// Since version: 1.0
	DestPark *string `form:"destPark,omitempty" json:"destPark,omitempty"`

	// DestMeta Enables using one or more predefined individual transport meta profile at the end of a trip. The profiles are defined in the HAFAS installation. String not longer than 512.
	//
	// Since version: 1.23.25
	DestMeta *string `form:"destMeta,omitempty" json:"destMeta,omitempty"`

	// TotalWalk Enables/disables using footpaths for the whole trip. String not longer than 1024.
	//
	// Since version: 1.23.20
	TotalWalk *string `form:"totalWalk,omitempty" json:"totalWalk,omitempty"`

	// TotalBike Enables/disables using bike routes for the whole trip. String not longer than 1024.
	//
	// Since version: 1.23.20
	TotalBike *string `form:"totalBike,omitempty" json:"totalBike,omitempty"`

	// TotalCar Enables/disables using car routes for the whole trip. String not longer than 1024.
	//
	// Since version: 1.23.20
	TotalCar *string `form:"totalCar,omitempty" json:"totalCar,omitempty"`

	// TotalTaxi Enables/disables using taxi rides for the whole trip. String not longer than 1024.
	//
	// Since version: 1.23.20
	TotalTaxi *string `form:"totalTaxi,omitempty" json:"totalTaxi,omitempty"`

	// TotalMeta Enables using one or more predefined individual transport meta profile for a trip. The profiles are defined in the HAFAS installation. String not longer than 512.
	//
	// Since version: 1.23.25
	TotalMeta *string `form:"totalMeta,omitempty" json:"totalMeta,omitempty"`

	// GisProducts Filter on GIS product, e.g. specific sharing provider. Currently, only exclusion of certain providers is available by adding ! in front of the provider meta code. Available codes are customer specific. String not longer than 8096.
	//
	// Since version: 2.19
	GisProducts *string `form:"gisProducts,omitempty" json:"gisProducts,omitempty"`

	// IncludeIv Enables/disables search for individual transport routes.
	//
	// Since version: 2.6.5
	IncludeIv *Verb11ParamsIncludeIv `form:"includeIv,omitempty" json:"includeIv,omitempty"`

	// IvOnly Enables/disables search for individual transport routes only.
	//
	// Since version: 1.23.20
	IvOnly *Verb11ParamsIvOnly `form:"ivOnly,omitempty" json:"ivOnly,omitempty"`

	// IncludeDrt Enables/disables search for DRT routes.
	//
	// Since version: 2.42
	IncludeDrt *Verb11ParamsIncludeDrt `form:"includeDrt,omitempty" json:"includeDrt,omitempty"`

	// MobilityProfile Use a predefined filter by its name. The filters are defined in the HAFAS installation. If the filter should be negated, put a ! in front of its name. String not longer than 512.
	//
	// Since version: 1.0
	MobilityProfile *string `form:"mobilityProfile,omitempty" json:"mobilityProfile,omitempty"`

	// BikeCarriage Enables/disables search for trips explicit allowing bike carriage.
	//
	// Since version: 1.0
	BikeCarriage *Verb11ParamsBikeCarriage `form:"bikeCarriage,omitempty" json:"bikeCarriage,omitempty"`

	// BikeCarriageType Filter for a specific bike carriage type. Allowed types are SINGLEBIKES, SMALLGROUPS and LARGEGROUPS. May be not available in any installation.
	//
	// Since version: 2.16
	BikeCarriageType *Verb11ParamsBikeCarriageType `form:"bikeCarriageType,omitempty" json:"bikeCarriageType,omitempty"`

	// SleepingCar Enables/disables search for trips having sleeping car.
	//
	// Since version: 1.0
	SleepingCar *Verb11ParamsSleepingCar `form:"sleepingCar,omitempty" json:"sleepingCar,omitempty"`

	// CouchetteCoach Enables/disables search for trips having couchette coach.
	//
	// Since version: 1.0
	CouchetteCoach *Verb11ParamsCouchetteCoach `form:"couchetteCoach,omitempty" json:"couchetteCoach,omitempty"`

	// ShowPassingPoints Enables/disables the return of stops having no alighting and boarding in its passlist for each leg of the trip. Needs passlist enabled.
	//
	// Since version: 1.0
	ShowPassingPoints *Verb11ParamsShowPassingPoints `form:"showPassingPoints,omitempty" json:"showPassingPoints,omitempty"`

	// Baim Enables/disables BAIM search and response.
	//
	// Since version: 1.23.8
	Baim *Verb11ParamsBaim `form:"baim,omitempty" json:"baim,omitempty"`

	// Eco Only supported if legacy environmental calculator is used.
	//
	// Deprecated. Enables/disables eco value calculation.
	//
	// Since version: 1.23.9
	Eco *Verb11ParamsEco `form:"eco,omitempty" json:"eco,omitempty"`

	// EcoCmp Only supported if legacy environmental calculator is used.
	//
	// Deprecated. Enables/disables eco comparison.
	//
	// Since version: 1.23.9
	EcoCmp *Verb11ParamsEcoCmp `form:"ecoCmp,omitempty" json:"ecoCmp,omitempty"`

	// EcoParams Provide additional eco parameters. String not longer than 1024.
	//
	// Since version: 1.23.9
	EcoParams *string `form:"ecoParams,omitempty" json:"ecoParams,omitempty"`

	// RtMode Set the realtime mode to be used.
	//
	// Since version: 1.0
	RtMode *Verb11ParamsRtMode `form:"rtMode,omitempty" json:"rtMode,omitempty"`

	// Unsharp Enables/disables unsharp search mode.
	//
	// Since version: 1.23.13
	Unsharp *Verb11ParamsUnsharp `form:"unsharp,omitempty" json:"unsharp,omitempty"`

	// TrainFilter Filters a trip search for a certain train. String not longer than 1024.
	//
	// Since version: 1.23.9
	TrainFilter *string `form:"trainFilter,omitempty" json:"trainFilter,omitempty"`

	// Economic Enables/disables economic search mode.
	//
	// Since version: 1.23.14
	Economic *Verb11ParamsEconomic `form:"economic,omitempty" json:"economic,omitempty"`

	// AllowFootpathEquivalences If the walk is disabled or a maximum walk distance of 0 is set and all other gis modalities are disabled HAFAS is allowed to use start/destination equivalences that are connected by a data foot path.
	//
	// Since version: 2.26
	AllowFootpathEquivalences *Verb11ParamsAllowFootpathEquivalences `form:"allowFootpathEquivalences,omitempty" json:"allowFootpathEquivalences,omitempty"`

	// GroupFilter Use a predefined group filter to query for certain modes. String not longer than 512.
	//
	// Since version: 1.23.14
	GroupFilter *string `form:"groupFilter,omitempty" json:"groupFilter,omitempty"`

	// BlockingList Defines a section of a route of a journey not to be used within the trip search. String not longer than 32768.
	//
	// Since version: 1.23.18
	BlockingList *string `form:"blockingList,omitempty" json:"blockingList,omitempty"`

	// BlockedEdges List of edges within the public transport network that should be excluded from the result. String not longer than 32768.
	//
	// Since version: 2.22
	BlockedEdges *string `form:"blockedEdges,omitempty" json:"blockedEdges,omitempty"`

	// TrainComposition Enables/disables train composition data.
	//
	// Since version: 1.0
	TrainComposition *Verb11ParamsTrainComposition `form:"trainComposition,omitempty" json:"trainComposition,omitempty"`

	// IncludeEarlier Disables search optimization in relation of duration.
	//
	// Since version: 1.23.18
	IncludeEarlier *Verb11ParamsIncludeEarlier `form:"includeEarlier,omitempty" json:"includeEarlier,omitempty"`

	// WithICTAlternatives Enables/disables the search for alternatives with individualized change times (ICT).
	//
	// Since version: 1.23.19
	WithICTAlternatives *Verb11ParamsWithICTAlternatives `form:"withICTAlternatives,omitempty" json:"withICTAlternatives,omitempty"`

	// Tariff Enables/disables the output of tariff data. The default is configurable via provisioning.
	//
	// Since version: 2.7
	Tariff *Verb11ParamsTariff `form:"tariff,omitempty" json:"tariff,omitempty"`

	// TrafficMessages Enables/disables the output of traffic messages. The default is configurable via provisioning.
	//
	// Since version: 2.7
	TrafficMessages *Verb11ParamsTrafficMessages `form:"trafficMessages,omitempty" json:"trafficMessages,omitempty"`

	// TravellerProfileData Traveller profile data. Structure depends on set up. String not longer than 32768.
	//
	// Since version: 2.15
	TravellerProfileData *string `form:"travellerProfileData,omitempty" json:"travellerProfileData,omitempty"`

	// WithFreq Enables/disables the calculation of frequency information.
	//
	// Since version: 2.18
	WithFreq *Verb11ParamsWithFreq `form:"withFreq,omitempty" json:"withFreq,omitempty"`

	// WithJourneyBoundaryPoints Enables/disables the return of journey boundary stops at public transport legs.
	//
	// Since version: 2.24
	WithJourneyBoundaryPoints *Verb11ParamsWithJourneyBoundaryPoints `form:"withJourneyBoundaryPoints,omitempty" json:"withJourneyBoundaryPoints,omitempty"`
}

// Verb11ParamsFormat defines parameters for Verb11.
type Verb11ParamsFormat string

// Verb11ParamsOriginCoordType defines parameters for Verb11.
type Verb11ParamsOriginCoordType string

// Verb11ParamsDestCoordType defines parameters for Verb11.
type Verb11ParamsDestCoordType string

// Verb11ParamsSearchForArrival defines parameters for Verb11.
type Verb11ParamsSearchForArrival string

// Verb11ParamsPoly defines parameters for Verb11.
type Verb11ParamsPoly string

// Verb11ParamsPolyEnc defines parameters for Verb11.
type Verb11ParamsPolyEnc string

// Verb11ParamsPasslist defines parameters for Verb11.
type Verb11ParamsPasslist string

// Verb11ParamsIncludeIv defines parameters for Verb11.
type Verb11ParamsIncludeIv string

// Verb11ParamsIvOnly defines parameters for Verb11.
type Verb11ParamsIvOnly string

// Verb11ParamsIncludeDrt defines parameters for Verb11.
type Verb11ParamsIncludeDrt string

// Verb11ParamsBikeCarriage defines parameters for Verb11.
type Verb11ParamsBikeCarriage string

// Verb11ParamsBikeCarriageType defines parameters for Verb11.
type Verb11ParamsBikeCarriageType string

// Verb11ParamsSleepingCar defines parameters for Verb11.
type Verb11ParamsSleepingCar string

// Verb11ParamsCouchetteCoach defines parameters for Verb11.
type Verb11ParamsCouchetteCoach string

// Verb11ParamsShowPassingPoints defines parameters for Verb11.
type Verb11ParamsShowPassingPoints string

// Verb11ParamsBaim defines parameters for Verb11.
type Verb11ParamsBaim string

// Verb11ParamsEco defines parameters for Verb11.
type Verb11ParamsEco string

// Verb11ParamsEcoCmp defines parameters for Verb11.
type Verb11ParamsEcoCmp string

// Verb11ParamsRtMode defines parameters for Verb11.
type Verb11ParamsRtMode string

// Verb11ParamsUnsharp defines parameters for Verb11.
type Verb11ParamsUnsharp string

// Verb11ParamsEconomic defines parameters for Verb11.
type Verb11ParamsEconomic string

// Verb11ParamsAllowFootpathEquivalences defines parameters for Verb11.
type Verb11ParamsAllowFootpathEquivalences string

// Verb11ParamsTrainComposition defines parameters for Verb11.
type Verb11ParamsTrainComposition string

// Verb11ParamsIncludeEarlier defines parameters for Verb11.
type Verb11ParamsIncludeEarlier string

// Verb11ParamsWithICTAlternatives defines parameters for Verb11.
type Verb11ParamsWithICTAlternatives string

// Verb11ParamsTariff defines parameters for Verb11.
type Verb11ParamsTariff string

// Verb11ParamsTrafficMessages defines parameters for Verb11.
type Verb11ParamsTrafficMessages string

// Verb11ParamsWithFreq defines parameters for Verb11.
type Verb11ParamsWithFreq string

// Verb11ParamsWithJourneyBoundaryPoints defines parameters for Verb11.
type Verb11ParamsWithJourneyBoundaryPoints string

// AsStopLocation returns the union data inside the LocationList_StopLocationOrCoordLocation_Item as a StopLocation
func (t LocationList_StopLocationOrCoordLocation_Item) AsStopLocation() (StopLocation, error) {
	var body StopLocation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStopLocation overwrites any union data inside the LocationList_StopLocationOrCoordLocation_Item as the provided StopLocation
func (t *LocationList_StopLocationOrCoordLocation_Item) FromStopLocation(v StopLocation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStopLocation performs a merge with any union data inside the LocationList_StopLocationOrCoordLocation_Item, using the provided StopLocation
func (t *LocationList_StopLocationOrCoordLocation_Item) MergeStopLocation(v StopLocation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCoordLocation returns the union data inside the LocationList_StopLocationOrCoordLocation_Item as a CoordLocation
func (t LocationList_StopLocationOrCoordLocation_Item) AsCoordLocation() (CoordLocation, error) {
	var body CoordLocation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCoordLocation overwrites any union data inside the LocationList_StopLocationOrCoordLocation_Item as the provided CoordLocation
func (t *LocationList_StopLocationOrCoordLocation_Item) FromCoordLocation(v CoordLocation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCoordLocation performs a merge with any union data inside the LocationList_StopLocationOrCoordLocation_Item, using the provided CoordLocation
func (t *LocationList_StopLocationOrCoordLocation_Item) MergeCoordLocation(v CoordLocation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LocationList_StopLocationOrCoordLocation_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LocationList_StopLocationOrCoordLocation_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Verb1 request
	Verb1(ctx context.Context, params *Verb1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Verb2 request
	Verb2(ctx context.Context, params *Verb2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Verb3 request
	Verb3(ctx context.Context, params *Verb3Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Verb4 request
	Verb4(ctx context.Context, params *Verb4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Verb5 request
	Verb5(ctx context.Context, params *Verb5Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Verb6 request
	Verb6(ctx context.Context, params *Verb6Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Verb7 request
	Verb7(ctx context.Context, params *Verb7Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Verb8 request
	Verb8(ctx context.Context, params *Verb8Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Verb9 request
	Verb9(ctx context.Context, params *Verb9Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Verb10 request
	Verb10(ctx context.Context, params *Verb10Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Verb12 request
	Verb12(ctx context.Context, params *Verb12Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Verb11 request
	Verb11(ctx context.Context, params *Verb11Params, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Verb1(ctx context.Context, params *Verb1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerb1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Verb2(ctx context.Context, params *Verb2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerb2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Verb3(ctx context.Context, params *Verb3Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerb3Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Verb4(ctx context.Context, params *Verb4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerb4Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Verb5(ctx context.Context, params *Verb5Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerb5Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Verb6(ctx context.Context, params *Verb6Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerb6Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Verb7(ctx context.Context, params *Verb7Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerb7Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Verb8(ctx context.Context, params *Verb8Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerb8Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Verb9(ctx context.Context, params *Verb9Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerb9Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Verb10(ctx context.Context, params *Verb10Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerb10Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Verb12(ctx context.Context, params *Verb12Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerb12Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Verb11(ctx context.Context, params *Verb11Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerb11Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewVerb1Request generates requests for Verb1
func NewVerb1Request(server string, params *Verb1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/arrivalBoard")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestId", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JsonpCallback != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpCallback", runtime.ParamLocationQuery, *params.JsonpCallback); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lang != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExtId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extId", runtime.ParamLocationQuery, *params.ExtId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxJourneys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxJourneys", runtime.ParamLocationQuery, *params.MaxJourneys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Products != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "products", runtime.ParamLocationQuery, *params.Products); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Operators != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operators", runtime.ParamLocationQuery, *params.Operators); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Categories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories", runtime.ParamLocationQuery, *params.Categories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lines", runtime.ParamLocationQuery, *params.Lines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Attributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attributes", runtime.ParamLocationQuery, *params.Attributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Platforms != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platforms", runtime.ParamLocationQuery, *params.Platforms); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Passlist != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "passlist", runtime.ParamLocationQuery, *params.Passlist); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PasslistMaxStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "passlistMaxStops", runtime.ParamLocationQuery, *params.PasslistMaxStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDur", runtime.ParamLocationQuery, *params.MinDur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Baim != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "baim", runtime.ParamLocationQuery, *params.Baim); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RtMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rtMode", runtime.ParamLocationQuery, *params.RtMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerb2Request generates requests for Verb2
func NewVerb2Request(server string, params *Verb2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/datainfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestId", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JsonpCallback != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpCallback", runtime.ParamLocationQuery, *params.JsonpCallback); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lang != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerb3Request generates requests for Verb3
func NewVerb3Request(server string, params *Verb3Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/departureBoard")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestId", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JsonpCallback != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpCallback", runtime.ParamLocationQuery, *params.JsonpCallback); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lang != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExtId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extId", runtime.ParamLocationQuery, *params.ExtId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxJourneys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxJourneys", runtime.ParamLocationQuery, *params.MaxJourneys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Products != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "products", runtime.ParamLocationQuery, *params.Products); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Operators != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operators", runtime.ParamLocationQuery, *params.Operators); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Categories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories", runtime.ParamLocationQuery, *params.Categories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lines", runtime.ParamLocationQuery, *params.Lines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Attributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attributes", runtime.ParamLocationQuery, *params.Attributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Platforms != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platforms", runtime.ParamLocationQuery, *params.Platforms); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Passlist != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "passlist", runtime.ParamLocationQuery, *params.Passlist); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PasslistMaxStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "passlistMaxStops", runtime.ParamLocationQuery, *params.PasslistMaxStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDur", runtime.ParamLocationQuery, *params.MinDur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Baim != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "baim", runtime.ParamLocationQuery, *params.Baim); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RtMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rtMode", runtime.ParamLocationQuery, *params.RtMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerb4Request generates requests for Verb4
func NewVerb4Request(server string, params *Verb4Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gisroute")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestId", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JsonpCallback != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpCallback", runtime.ParamLocationQuery, *params.JsonpCallback); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lang != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ctx", runtime.ParamLocationQuery, params.Ctx); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Poly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poly", runtime.ParamLocationQuery, *params.Poly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolyEnc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "polyEnc", runtime.ParamLocationQuery, *params.PolyEnc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Eco != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eco", runtime.ParamLocationQuery, *params.Eco); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Baim != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "baim", runtime.ParamLocationQuery, *params.Baim); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerb5Request generates requests for Verb5
func NewVerb5Request(server string, params *Verb5Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/himsearch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestId", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JsonpCallback != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpCallback", runtime.ParamLocationQuery, *params.JsonpCallback); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lang != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateB != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateB", runtime.ParamLocationQuery, *params.DateB); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateE != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dateE", runtime.ParamLocationQuery, *params.DateE); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeB != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeB", runtime.ParamLocationQuery, *params.TimeB); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeE != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeE", runtime.ParamLocationQuery, *params.TimeE); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Weekdays != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "weekdays", runtime.ParamLocationQuery, *params.Weekdays); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HimIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "himIds", runtime.ParamLocationQuery, *params.HimIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HierarchicalView != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hierarchicalView", runtime.ParamLocationQuery, *params.HierarchicalView); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Operators != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operators", runtime.ParamLocationQuery, *params.Operators); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Categories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories", runtime.ParamLocationQuery, *params.Categories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Channels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channels", runtime.ParamLocationQuery, *params.Channels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Companies != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "companies", runtime.ParamLocationQuery, *params.Companies); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lines", runtime.ParamLocationQuery, *params.Lines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lineids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lineids", runtime.ParamLocationQuery, *params.Lineids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stations", runtime.ParamLocationQuery, *params.Stations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fromstation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromstation", runtime.ParamLocationQuery, *params.Fromstation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tostation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tostation", runtime.ParamLocationQuery, *params.Tostation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bothways != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bothways", runtime.ParamLocationQuery, *params.Bothways); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Trainnames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trainnames", runtime.ParamLocationQuery, *params.Trainnames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Metas != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metas", runtime.ParamLocationQuery, *params.Metas); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Himcategory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "himcategory", runtime.ParamLocationQuery, *params.Himcategory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Himtags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "himtags", runtime.ParamLocationQuery, *params.Himtags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Regions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "regions", runtime.ParamLocationQuery, *params.Regions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Himtext != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "himtext", runtime.ParamLocationQuery, *params.Himtext); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Himtexttags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "himtexttags", runtime.ParamLocationQuery, *params.Himtexttags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Exthimtext != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exthimtext", runtime.ParamLocationQuery, *params.Exthimtext); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Additionalfields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additionalfields", runtime.ParamLocationQuery, *params.Additionalfields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExtInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extInfo", runtime.ParamLocationQuery, *params.ExtInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Poly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poly", runtime.ParamLocationQuery, *params.Poly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Searchmode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchmode", runtime.ParamLocationQuery, *params.Searchmode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AffectedJourneyMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "affectedJourneyMode", runtime.ParamLocationQuery, *params.AffectedJourneyMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AffectedJourneyStopMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "affectedJourneyStopMode", runtime.ParamLocationQuery, *params.AffectedJourneyStopMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderBy", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Minprio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minprio", runtime.ParamLocationQuery, *params.Minprio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Maxprio != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxprio", runtime.ParamLocationQuery, *params.Maxprio); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LlLat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "llLat", runtime.ParamLocationQuery, *params.LlLat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LlLon != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "llLon", runtime.ParamLocationQuery, *params.LlLon); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UrLat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "urLat", runtime.ParamLocationQuery, *params.UrLat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UrLon != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "urLon", runtime.ParamLocationQuery, *params.UrLon); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerb6Request generates requests for Verb6
func NewVerb6Request(server string, params *Verb6Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/journeyDetail")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestId", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JsonpCallback != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpCallback", runtime.ParamLocationQuery, *params.JsonpCallback); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lang != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Poly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poly", runtime.ParamLocationQuery, *params.Poly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolyEnc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "polyEnc", runtime.ParamLocationQuery, *params.PolyEnc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowPassingPoints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "showPassingPoints", runtime.ParamLocationQuery, *params.ShowPassingPoints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RtMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rtMode", runtime.ParamLocationQuery, *params.RtMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromId", runtime.ParamLocationQuery, *params.FromId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromIdx != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromIdx", runtime.ParamLocationQuery, *params.FromIdx); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toId", runtime.ParamLocationQuery, *params.ToId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToIdx != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toIdx", runtime.ParamLocationQuery, *params.ToIdx); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Baim != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "baim", runtime.ParamLocationQuery, *params.Baim); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerb7Request generates requests for Verb7
func NewVerb7Request(server string, params *Verb7Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/journeypos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestId", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JsonpCallback != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpCallback", runtime.ParamLocationQuery, *params.JsonpCallback); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lang != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "llLat", runtime.ParamLocationQuery, params.LlLat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "llLon", runtime.ParamLocationQuery, params.LlLon); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "urLat", runtime.ParamLocationQuery, params.UrLat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "urLon", runtime.ParamLocationQuery, params.UrLon); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Operators != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operators", runtime.ParamLocationQuery, *params.Operators); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Products != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "products", runtime.ParamLocationQuery, *params.Products); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Attributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attributes", runtime.ParamLocationQuery, *params.Attributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Jid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jid", runtime.ParamLocationQuery, *params.Jid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lines", runtime.ParamLocationQuery, *params.Lines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Infotexts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "infotexts", runtime.ParamLocationQuery, *params.Infotexts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxJny != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxJny", runtime.ParamLocationQuery, *params.MaxJny); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "periodSize", runtime.ParamLocationQuery, *params.PeriodSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PeriodStep != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "periodStep", runtime.ParamLocationQuery, *params.PeriodStep); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PositionMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "positionMode", runtime.ParamLocationQuery, *params.PositionMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerb8Request generates requests for Verb8
func NewVerb8Request(server string, params *Verb8Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location.name")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestId", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JsonpCallback != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpCallback", runtime.ParamLocationQuery, *params.JsonpCallback); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lang != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "input", runtime.ParamLocationQuery, params.Input); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MaxNo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxNo", runtime.ParamLocationQuery, *params.MaxNo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationSelectionMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locationSelectionMode", runtime.ParamLocationQuery, *params.LocationSelectionMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithEquivalentLocations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withEquivalentLocations", runtime.ParamLocationQuery, *params.WithEquivalentLocations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RestrictSelection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "restrictSelection", runtime.ParamLocationQuery, *params.RestrictSelection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Products != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "products", runtime.ParamLocationQuery, *params.Products); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithProducts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withProducts", runtime.ParamLocationQuery, *params.WithProducts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductRepresentatives != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productRepresentatives", runtime.ParamLocationQuery, *params.ProductRepresentatives); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CoordLat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "coordLat", runtime.ParamLocationQuery, *params.CoordLat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CoordLong != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "coordLong", runtime.ParamLocationQuery, *params.CoordLong); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.R != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "r", runtime.ParamLocationQuery, *params.R); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RefineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refineId", runtime.ParamLocationQuery, *params.RefineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stations", runtime.ParamLocationQuery, *params.Stations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sattributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sattributes", runtime.ParamLocationQuery, *params.Sattributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sinfotexts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sinfotexts", runtime.ParamLocationQuery, *params.Sinfotexts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterMode", runtime.ParamLocationQuery, *params.FilterMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PoolId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poolId", runtime.ParamLocationQuery, *params.PoolId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerb9Request generates requests for Verb9
func NewVerb9Request(server string, params *Verb9Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location.nearbystops")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestId", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JsonpCallback != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpCallback", runtime.ParamLocationQuery, *params.JsonpCallback); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lang != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originCoordLat", runtime.ParamLocationQuery, params.OriginCoordLat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originCoordLong", runtime.ParamLocationQuery, params.OriginCoordLong); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.R != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "r", runtime.ParamLocationQuery, *params.R); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxNo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxNo", runtime.ParamLocationQuery, *params.MaxNo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationSelectionMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locationSelectionMode", runtime.ParamLocationQuery, *params.LocationSelectionMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Products != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "products", runtime.ParamLocationQuery, *params.Products); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sattributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sattributes", runtime.ParamLocationQuery, *params.Sattributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sinfotexts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sinfotexts", runtime.ParamLocationQuery, *params.Sinfotexts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PoolId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poolId", runtime.ParamLocationQuery, *params.PoolId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Zoom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "zoom", runtime.ParamLocationQuery, *params.Zoom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PoiCategories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poiCategories", runtime.ParamLocationQuery, *params.PoiCategories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerb10Request generates requests for Verb10
func NewVerb10Request(server string, params *Verb10Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recon")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestId", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JsonpCallback != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpCallback", runtime.ParamLocationQuery, *params.JsonpCallback); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lang != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ctx", runtime.ParamLocationQuery, params.Ctx); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Poly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poly", runtime.ParamLocationQuery, *params.Poly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolyEnc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "polyEnc", runtime.ParamLocationQuery, *params.PolyEnc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UseCombinedComparison != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useCombinedComparison", runtime.ParamLocationQuery, *params.UseCombinedComparison); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AcceptGaps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "acceptGaps", runtime.ParamLocationQuery, *params.AcceptGaps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowDummySections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowDummySections", runtime.ParamLocationQuery, *params.AllowDummySections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FlagAllNonReachable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flagAllNonReachable", runtime.ParamLocationQuery, *params.FlagAllNonReachable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MatchCatStrict != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "matchCatStrict", runtime.ParamLocationQuery, *params.MatchCatStrict); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MatchIdNonBlank != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "matchIdNonBlank", runtime.ParamLocationQuery, *params.MatchIdNonBlank); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MatchIdStrict != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "matchIdStrict", runtime.ParamLocationQuery, *params.MatchIdStrict); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MatchNumStrict != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "matchNumStrict", runtime.ParamLocationQuery, *params.MatchNumStrict); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MatchRtType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "matchRtType", runtime.ParamLocationQuery, *params.MatchRtType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableRtFullSearch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableRtFullSearch", runtime.ParamLocationQuery, *params.EnableRtFullSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableReplacements != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableReplacements", runtime.ParamLocationQuery, *params.EnableReplacements); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArrL != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrL", runtime.ParamLocationQuery, *params.ArrL); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArrU != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrU", runtime.ParamLocationQuery, *params.ArrU); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DepL != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depL", runtime.ParamLocationQuery, *params.DepL); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DepU != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depU", runtime.ParamLocationQuery, *params.DepU); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Passlist != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "passlist", runtime.ParamLocationQuery, *params.Passlist); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowPassingPoints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "showPassingPoints", runtime.ParamLocationQuery, *params.ShowPassingPoints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RtMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rtMode", runtime.ParamLocationQuery, *params.RtMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Baim != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "baim", runtime.ParamLocationQuery, *params.Baim); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Eco != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eco", runtime.ParamLocationQuery, *params.Eco); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EcoCmp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ecoCmp", runtime.ParamLocationQuery, *params.EcoCmp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EcoParams != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ecoParams", runtime.ParamLocationQuery, *params.EcoParams); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tariff != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tariff", runtime.ParamLocationQuery, *params.Tariff); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TrafficMessages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trafficMessages", runtime.ParamLocationQuery, *params.TrafficMessages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TravellerProfileData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "travellerProfileData", runtime.ParamLocationQuery, *params.TravellerProfileData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithJourneyBoundaryPoints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withJourneyBoundaryPoints", runtime.ParamLocationQuery, *params.WithJourneyBoundaryPoints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Freq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "freq", runtime.ParamLocationQuery, *params.Freq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerb12Request generates requests for Verb12
func NewVerb12Request(server string, params *Verb12Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/systemInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerb11Request generates requests for Verb11
func NewVerb11Request(server string, params *Verb11Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestId", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JsonpCallback != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpCallback", runtime.ParamLocationQuery, *params.JsonpCallback); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lang != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originId", runtime.ParamLocationQuery, *params.OriginId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginExtId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originExtId", runtime.ParamLocationQuery, *params.OriginExtId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginCoordLat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originCoordLat", runtime.ParamLocationQuery, *params.OriginCoordLat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginCoordLong != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originCoordLong", runtime.ParamLocationQuery, *params.OriginCoordLong); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginCoordName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originCoordName", runtime.ParamLocationQuery, *params.OriginCoordName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginCoordType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originCoordType", runtime.ParamLocationQuery, *params.OriginCoordType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destId", runtime.ParamLocationQuery, *params.DestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestExtId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destExtId", runtime.ParamLocationQuery, *params.DestExtId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestCoordLat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destCoordLat", runtime.ParamLocationQuery, *params.DestCoordLat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestCoordLong != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destCoordLong", runtime.ParamLocationQuery, *params.DestCoordLong); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestCoordName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destCoordName", runtime.ParamLocationQuery, *params.DestCoordName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestCoordType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destCoordType", runtime.ParamLocationQuery, *params.DestCoordType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Via != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "via", runtime.ParamLocationQuery, *params.Via); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ViaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "viaId", runtime.ParamLocationQuery, *params.ViaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ViaWaitTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "viaWaitTime", runtime.ParamLocationQuery, *params.ViaWaitTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Avoid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avoid", runtime.ParamLocationQuery, *params.Avoid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvoidId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avoidId", runtime.ParamLocationQuery, *params.AvoidId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ViaGis != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "viaGis", runtime.ParamLocationQuery, *params.ViaGis); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChangeTimePercent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "changeTimePercent", runtime.ParamLocationQuery, *params.ChangeTimePercent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinChangeTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minChangeTime", runtime.ParamLocationQuery, *params.MinChangeTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxChangeTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxChangeTime", runtime.ParamLocationQuery, *params.MaxChangeTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddChangeTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addChangeTime", runtime.ParamLocationQuery, *params.AddChangeTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxChange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxChange", runtime.ParamLocationQuery, *params.MaxChange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchForArrival != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchForArrival", runtime.ParamLocationQuery, *params.SearchForArrival); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NumF != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "numF", runtime.ParamLocationQuery, *params.NumF); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NumB != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "numB", runtime.ParamLocationQuery, *params.NumB); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Poly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poly", runtime.ParamLocationQuery, *params.Poly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolyEnc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "polyEnc", runtime.ParamLocationQuery, *params.PolyEnc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Passlist != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "passlist", runtime.ParamLocationQuery, *params.Passlist); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Products != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "products", runtime.ParamLocationQuery, *params.Products); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Operators != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operators", runtime.ParamLocationQuery, *params.Operators); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Categories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories", runtime.ParamLocationQuery, *params.Categories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CategoryFlags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categoryFlags", runtime.ParamLocationQuery, *params.CategoryFlags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Attributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attributes", runtime.ParamLocationQuery, *params.Attributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sattributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sattributes", runtime.ParamLocationQuery, *params.Sattributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fattributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fattributes", runtime.ParamLocationQuery, *params.Fattributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lines", runtime.ParamLocationQuery, *params.Lines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lineids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lineids", runtime.ParamLocationQuery, *params.Lineids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvoidPaths != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "avoidPaths", runtime.ParamLocationQuery, *params.AvoidPaths); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginWalk != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originWalk", runtime.ParamLocationQuery, *params.OriginWalk); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginBike != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originBike", runtime.ParamLocationQuery, *params.OriginBike); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginCar != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originCar", runtime.ParamLocationQuery, *params.OriginCar); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginTaxi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originTaxi", runtime.ParamLocationQuery, *params.OriginTaxi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginPark != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originPark", runtime.ParamLocationQuery, *params.OriginPark); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginMeta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originMeta", runtime.ParamLocationQuery, *params.OriginMeta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestWalk != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destWalk", runtime.ParamLocationQuery, *params.DestWalk); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestBike != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destBike", runtime.ParamLocationQuery, *params.DestBike); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestCar != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destCar", runtime.ParamLocationQuery, *params.DestCar); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestTaxi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destTaxi", runtime.ParamLocationQuery, *params.DestTaxi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestPark != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destPark", runtime.ParamLocationQuery, *params.DestPark); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestMeta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destMeta", runtime.ParamLocationQuery, *params.DestMeta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalWalk != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "totalWalk", runtime.ParamLocationQuery, *params.TotalWalk); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalBike != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "totalBike", runtime.ParamLocationQuery, *params.TotalBike); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalCar != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "totalCar", runtime.ParamLocationQuery, *params.TotalCar); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalTaxi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "totalTaxi", runtime.ParamLocationQuery, *params.TotalTaxi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalMeta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "totalMeta", runtime.ParamLocationQuery, *params.TotalMeta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GisProducts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gisProducts", runtime.ParamLocationQuery, *params.GisProducts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeIv != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeIv", runtime.ParamLocationQuery, *params.IncludeIv); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IvOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ivOnly", runtime.ParamLocationQuery, *params.IvOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDrt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeDrt", runtime.ParamLocationQuery, *params.IncludeDrt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MobilityProfile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mobilityProfile", runtime.ParamLocationQuery, *params.MobilityProfile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BikeCarriage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bikeCarriage", runtime.ParamLocationQuery, *params.BikeCarriage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BikeCarriageType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bikeCarriageType", runtime.ParamLocationQuery, *params.BikeCarriageType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SleepingCar != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sleepingCar", runtime.ParamLocationQuery, *params.SleepingCar); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CouchetteCoach != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "couchetteCoach", runtime.ParamLocationQuery, *params.CouchetteCoach); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowPassingPoints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "showPassingPoints", runtime.ParamLocationQuery, *params.ShowPassingPoints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Baim != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "baim", runtime.ParamLocationQuery, *params.Baim); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Eco != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eco", runtime.ParamLocationQuery, *params.Eco); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EcoCmp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ecoCmp", runtime.ParamLocationQuery, *params.EcoCmp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EcoParams != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ecoParams", runtime.ParamLocationQuery, *params.EcoParams); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RtMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rtMode", runtime.ParamLocationQuery, *params.RtMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unsharp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unsharp", runtime.ParamLocationQuery, *params.Unsharp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TrainFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trainFilter", runtime.ParamLocationQuery, *params.TrainFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Economic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "economic", runtime.ParamLocationQuery, *params.Economic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowFootpathEquivalences != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowFootpathEquivalences", runtime.ParamLocationQuery, *params.AllowFootpathEquivalences); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupFilter", runtime.ParamLocationQuery, *params.GroupFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockingList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockingList", runtime.ParamLocationQuery, *params.BlockingList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockedEdges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockedEdges", runtime.ParamLocationQuery, *params.BlockedEdges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TrainComposition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trainComposition", runtime.ParamLocationQuery, *params.TrainComposition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeEarlier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeEarlier", runtime.ParamLocationQuery, *params.IncludeEarlier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithICTAlternatives != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withICTAlternatives", runtime.ParamLocationQuery, *params.WithICTAlternatives); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tariff != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tariff", runtime.ParamLocationQuery, *params.Tariff); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TrafficMessages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trafficMessages", runtime.ParamLocationQuery, *params.TrafficMessages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TravellerProfileData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "travellerProfileData", runtime.ParamLocationQuery, *params.TravellerProfileData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithFreq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withFreq", runtime.ParamLocationQuery, *params.WithFreq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithJourneyBoundaryPoints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withJourneyBoundaryPoints", runtime.ParamLocationQuery, *params.WithJourneyBoundaryPoints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// Verb1WithResponse request
	Verb1WithResponse(ctx context.Context, params *Verb1Params, reqEditors ...RequestEditorFn) (*Verb1Response, error)

	// Verb2WithResponse request
	Verb2WithResponse(ctx context.Context, params *Verb2Params, reqEditors ...RequestEditorFn) (*Verb2Response, error)

	// Verb3WithResponse request
	Verb3WithResponse(ctx context.Context, params *Verb3Params, reqEditors ...RequestEditorFn) (*Verb3Response, error)

	// Verb4WithResponse request
	Verb4WithResponse(ctx context.Context, params *Verb4Params, reqEditors ...RequestEditorFn) (*Verb4Response, error)

	// Verb5WithResponse request
	Verb5WithResponse(ctx context.Context, params *Verb5Params, reqEditors ...RequestEditorFn) (*Verb5Response, error)

	// Verb6WithResponse request
	Verb6WithResponse(ctx context.Context, params *Verb6Params, reqEditors ...RequestEditorFn) (*Verb6Response, error)

	// Verb7WithResponse request
	Verb7WithResponse(ctx context.Context, params *Verb7Params, reqEditors ...RequestEditorFn) (*Verb7Response, error)

	// Verb8WithResponse request
	Verb8WithResponse(ctx context.Context, params *Verb8Params, reqEditors ...RequestEditorFn) (*Verb8Response, error)

	// Verb9WithResponse request
	Verb9WithResponse(ctx context.Context, params *Verb9Params, reqEditors ...RequestEditorFn) (*Verb9Response, error)

	// Verb10WithResponse request
	Verb10WithResponse(ctx context.Context, params *Verb10Params, reqEditors ...RequestEditorFn) (*Verb10Response, error)

	// Verb12WithResponse request
	Verb12WithResponse(ctx context.Context, params *Verb12Params, reqEditors ...RequestEditorFn) (*Verb12Response, error)

	// Verb11WithResponse request
	Verb11WithResponse(ctx context.Context, params *Verb11Params, reqEditors ...RequestEditorFn) (*Verb11Response, error)
}

type Verb1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrivalBoard
	XML200       *ArrivalBoard
}

// Status returns HTTPResponse.Status
func (r Verb1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Verb1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Verb2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataInfo
	XML200       *DataInfo
}

// Status returns HTTPResponse.Status
func (r Verb2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Verb2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Verb3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DepartureBoard
	XML200       *DepartureBoard
}

// Status returns HTTPResponse.Status
func (r Verb3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Verb3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Verb4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TripList
	XML200       *TripList
}

// Status returns HTTPResponse.Status
func (r Verb4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Verb4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Verb5Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HimMessages
	XML200       *HimMessages
}

// Status returns HTTPResponse.Status
func (r Verb5Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Verb5Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Verb6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JourneyDetail
	XML200       *JourneyDetail
}

// Status returns HTTPResponse.Status
func (r Verb6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Verb6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Verb7Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JourneyList
	XML200       *JourneyList
}

// Status returns HTTPResponse.Status
func (r Verb7Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Verb7Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Verb8Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LocationList
	XML200       *LocationList
}

// Status returns HTTPResponse.Status
func (r Verb8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Verb8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Verb9Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LocationList
	XML200       *LocationList
}

// Status returns HTTPResponse.Status
func (r Verb9Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Verb9Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Verb10Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TripList
	XML200       *TripList
}

// Status returns HTTPResponse.Status
func (r Verb10Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Verb10Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Verb12Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r Verb12Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Verb12Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Verb11Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TripList
	XML200       *TripList
}

// Status returns HTTPResponse.Status
func (r Verb11Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Verb11Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// Verb1WithResponse request returning *Verb1Response
func (c *ClientWithResponses) Verb1WithResponse(ctx context.Context, params *Verb1Params, reqEditors ...RequestEditorFn) (*Verb1Response, error) {
	rsp, err := c.Verb1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerb1Response(rsp)
}

// Verb2WithResponse request returning *Verb2Response
func (c *ClientWithResponses) Verb2WithResponse(ctx context.Context, params *Verb2Params, reqEditors ...RequestEditorFn) (*Verb2Response, error) {
	rsp, err := c.Verb2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerb2Response(rsp)
}

// Verb3WithResponse request returning *Verb3Response
func (c *ClientWithResponses) Verb3WithResponse(ctx context.Context, params *Verb3Params, reqEditors ...RequestEditorFn) (*Verb3Response, error) {
	rsp, err := c.Verb3(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerb3Response(rsp)
}

// Verb4WithResponse request returning *Verb4Response
func (c *ClientWithResponses) Verb4WithResponse(ctx context.Context, params *Verb4Params, reqEditors ...RequestEditorFn) (*Verb4Response, error) {
	rsp, err := c.Verb4(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerb4Response(rsp)
}

// Verb5WithResponse request returning *Verb5Response
func (c *ClientWithResponses) Verb5WithResponse(ctx context.Context, params *Verb5Params, reqEditors ...RequestEditorFn) (*Verb5Response, error) {
	rsp, err := c.Verb5(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerb5Response(rsp)
}

// Verb6WithResponse request returning *Verb6Response
func (c *ClientWithResponses) Verb6WithResponse(ctx context.Context, params *Verb6Params, reqEditors ...RequestEditorFn) (*Verb6Response, error) {
	rsp, err := c.Verb6(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerb6Response(rsp)
}

// Verb7WithResponse request returning *Verb7Response
func (c *ClientWithResponses) Verb7WithResponse(ctx context.Context, params *Verb7Params, reqEditors ...RequestEditorFn) (*Verb7Response, error) {
	rsp, err := c.Verb7(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerb7Response(rsp)
}

// Verb8WithResponse request returning *Verb8Response
func (c *ClientWithResponses) Verb8WithResponse(ctx context.Context, params *Verb8Params, reqEditors ...RequestEditorFn) (*Verb8Response, error) {
	rsp, err := c.Verb8(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerb8Response(rsp)
}

// Verb9WithResponse request returning *Verb9Response
func (c *ClientWithResponses) Verb9WithResponse(ctx context.Context, params *Verb9Params, reqEditors ...RequestEditorFn) (*Verb9Response, error) {
	rsp, err := c.Verb9(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerb9Response(rsp)
}

// Verb10WithResponse request returning *Verb10Response
func (c *ClientWithResponses) Verb10WithResponse(ctx context.Context, params *Verb10Params, reqEditors ...RequestEditorFn) (*Verb10Response, error) {
	rsp, err := c.Verb10(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerb10Response(rsp)
}

// Verb12WithResponse request returning *Verb12Response
func (c *ClientWithResponses) Verb12WithResponse(ctx context.Context, params *Verb12Params, reqEditors ...RequestEditorFn) (*Verb12Response, error) {
	rsp, err := c.Verb12(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerb12Response(rsp)
}

// Verb11WithResponse request returning *Verb11Response
func (c *ClientWithResponses) Verb11WithResponse(ctx context.Context, params *Verb11Params, reqEditors ...RequestEditorFn) (*Verb11Response, error) {
	rsp, err := c.Verb11(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerb11Response(rsp)
}

// ParseVerb1Response parses an HTTP response from a Verb1WithResponse call
func ParseVerb1Response(rsp *http.Response) (*Verb1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Verb1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrivalBoard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest ArrivalBoard
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseVerb2Response parses an HTTP response from a Verb2WithResponse call
func ParseVerb2Response(rsp *http.Response) (*Verb2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Verb2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest DataInfo
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseVerb3Response parses an HTTP response from a Verb3WithResponse call
func ParseVerb3Response(rsp *http.Response) (*Verb3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Verb3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DepartureBoard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest DepartureBoard
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseVerb4Response parses an HTTP response from a Verb4WithResponse call
func ParseVerb4Response(rsp *http.Response) (*Verb4Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Verb4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TripList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest TripList
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseVerb5Response parses an HTTP response from a Verb5WithResponse call
func ParseVerb5Response(rsp *http.Response) (*Verb5Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Verb5Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HimMessages
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest HimMessages
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseVerb6Response parses an HTTP response from a Verb6WithResponse call
func ParseVerb6Response(rsp *http.Response) (*Verb6Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Verb6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JourneyDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest JourneyDetail
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseVerb7Response parses an HTTP response from a Verb7WithResponse call
func ParseVerb7Response(rsp *http.Response) (*Verb7Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Verb7Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JourneyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest JourneyList
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseVerb8Response parses an HTTP response from a Verb8WithResponse call
func ParseVerb8Response(rsp *http.Response) (*Verb8Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Verb8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LocationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest LocationList
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseVerb9Response parses an HTTP response from a Verb9WithResponse call
func ParseVerb9Response(rsp *http.Response) (*Verb9Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Verb9Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LocationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest LocationList
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseVerb10Response parses an HTTP response from a Verb10WithResponse call
func ParseVerb10Response(rsp *http.Response) (*Verb10Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Verb10Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TripList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest TripList
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseVerb12Response parses an HTTP response from a Verb12WithResponse call
func ParseVerb12Response(rsp *http.Response) (*Verb12Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Verb12Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseVerb11Response parses an HTTP response from a Verb11WithResponse call
func ParseVerb11Response(rsp *http.Response) (*Verb11Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Verb11Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TripList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest TripList
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}
