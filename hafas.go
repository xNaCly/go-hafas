// gohafas wraps the autogenerated openapi client provided by vbbraw which was
// generated from https://vbb-demo.demo2.hafas.cloud/api/fahrinfo/latest/api-doc via the flake.nix file at the root of this project
package gohafas

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"

	"github.com/xnacly/go-hafas/vbbraw"
)

func debugStruct[S any](s S) {
	out, err := json.MarshalIndent(s, "", "\t")
	if err != nil {
		panic(err)
	}
	fmt.Println(string(out))
}

// LocationsByName searches locations matching `nameOrAdress` by calling the
// location.name hafas endpoint
//
// WARNING: vbbraw.LocationList_StopLocationOrCoordLocation_Item is a tagged
// union and requires a call to .Unwrap() before .AsStopLocation() or
// .AsCoordLocation() deserialize to the correct values
//
// See hafas api docs 2.3
func (c *Client) LocationsByName(nameOrAdress string, opt *vbbraw.Verb8Params) ([]vbbraw.LocationList_StopLocationOrCoordLocation_Item, error) {
	if opt == nil {
		opt = &vbbraw.Verb8Params{}
	}
	opt.Input = nameOrAdress
	resp, err := c.ClientWithResponses.Verb8WithResponse(c.Context, opt)
	if err != nil {
		return nil, errors.Join(errors.New("Failed to request LocationsByName"), err)
	}

	if resp.StatusCode() != http.StatusOK {
		e := errorFromBytes(resp.Body)
		return nil, errors.Join(errors.New("Non 200 status code while requesting LocationsByName"), e)
	}

	return *resp.JSON200.StopLocationOrCoordLocation, nil
}

// LocationsBy searches locations matching `x` and `y` by calling the location.nearbystops hafas endpoint
//
// See hafas api docs 2.3
func (c *Client) LocationsByCoordinate(originCoordLat, originCoordLong float32, opt *vbbraw.Verb9Params) ([]vbbraw.StopLocation, error) {
	if opt == nil {
		opt = &vbbraw.Verb9Params{}
	}
	opt.OriginCoordLat = originCoordLat
	opt.OriginCoordLong = originCoordLong
	resp, err := c.ClientWithResponses.Verb9WithResponse(c.Context, opt)
	if err != nil {
		return nil, errors.Join(errors.New("Failed to request LocationsByCoordinate"), err)
	}

	if resp.StatusCode() != http.StatusOK {
		e := errorFromBytes(resp.Body)
		return nil, errors.Join(errors.New("Non 200 status code while requesting LocationsByCoordinate"), e)
	}

	// we cast all of these to StopLocation, since we know LocationsByCoordinate only returns StopLocation
	locationList := *resp.JSON200.StopLocationOrCoordLocation

	stopList := make([]vbbraw.StopLocation, len(locationList))
	for i, l := range locationList {
		err := l.Unwrap()
		if err != nil {
			return nil, errors.Join(errors.New("Failed to unwrap LocationList_StopLocationOrCoordLocation_Item"), err)
		}

		stopLocation, err := l.AsStopLocation()
		if err != nil {
			return nil, errors.Join(errors.New("Failed to convert LocationList_StopLocationOrCoordLocation_Item to a StopLocation"), err)
		}

		stopList[i] = stopLocation
	}

	return stopList, nil
}

// Arrivals retrieves the next arrivals at a specified location starting from the given time.
//
// See hafas api docs 2.26
func (c *Client) Arrivals(locationId string, date Time, opt *vbbraw.Verb1Params) ([]vbbraw.Arrival, error) {
	if opt == nil {
		opt = &vbbraw.Verb1Params{
			Type: "ARR_STATION",
		}
	}

	opt.Id = &locationId
	d, t := date.ToHafasDateAndTime()
	opt.Date = &d
	opt.Time = &t

	resp, err := c.ClientWithResponses.Verb1WithResponse(c.Context, opt)
	if err != nil {
		return nil, errors.Join(errors.New("Failed to request Arrivals"), err)
	}

	if resp.StatusCode() != http.StatusOK {
		e := errorFromBytes(resp.Body)
		return nil, errors.Join(errors.New("Non 200 status code while requesting Arrivals"), e)
	}

	return *resp.JSON200.Arrival, nil
}

// Departures retrieves the next departures at a specified location starting from the given time.
//
// See hafas api docs 2.26
func (c *Client) Departures(locationId string, date Time, opt *vbbraw.Verb3Params) ([]vbbraw.Departure, error) {
	if opt == nil {
		opt = &vbbraw.Verb3Params{
			Type: "DEP",
		}
	}

	opt.Id = &locationId
	d, t := date.ToHafasDateAndTime()
	opt.Date = &d
	opt.Time = &t

	resp, err := c.ClientWithResponses.Verb3WithResponse(c.Context, opt)
	if err != nil {
		return nil, errors.Join(errors.New("Failed to request Departures"), err)
	}

	if resp.StatusCode() != http.StatusOK {
		e := errorFromBytes(resp.Body)
		return nil, errors.Join(errors.New("Non 200 status code while requesting Departures"), e)
	}

	return *resp.JSON200.Departure, nil
}

// DataInfo returns details contained about operators, administrations, products and product categories.
//
// See hafas api docs 2.45
func (c *Client) DataInfo() (vbbraw.DataInfo, error) {
	var empty vbbraw.DataInfo
	opt := &vbbraw.Verb2Params{}
	resp, err := c.ClientWithResponses.Verb2WithResponse(c.Context, opt)
	if err != nil {
		return empty, errors.Join(errors.New("Failed to request DataInfo"), err)
	}

	if resp.StatusCode() != http.StatusOK {
		e := errorFromBytes(resp.Body)
		return empty, errors.Join(errors.New("Non 200 status code while requesting DataInfo"), e)
	}

	return *resp.JSON200, nil
}

// TripSearch computes a trip from opt.OriginId (or opt.originCoord(Lat|Long)) to opt.DestId (or opt.destCoord(Lat|Long))
//
// See hafas api docs 2.12
func (c *Client) TripSearch(time Time, opt *vbbraw.Verb11Params) ([]vbbraw.TripType, error) {
	if opt == nil {
		opt = &vbbraw.Verb11Params{}
	}

	d, t := time.ToHafasDateAndTime()
	opt.Date = &d
	opt.Time = &t

	resp, err := c.ClientWithResponses.Verb11WithResponse(c.Context, opt)
	if err != nil {
		return nil, errors.Join(errors.New("Failed to request Trip"), err)
	}

	if resp.StatusCode() != http.StatusOK {
		e := errorFromBytes(resp.Body)
		return nil, errors.Join(errors.New("Non 200 status code while requesting Trip"), e)
	}

	return *resp.JSON200.Trip, nil
}

// JourneyDetail delivers information about the complete route of a vehicle
//
// See hafas api docs 2.31
func (c *Client) JourneyDetail(id string, opt *vbbraw.Verb6Params) (vbbraw.JourneyDetail, error) {
	if opt == nil {
		opt = &vbbraw.Verb6Params{}
	}

	opt.Id = id

	var empty vbbraw.JourneyDetail

	resp, err := c.ClientWithResponses.Verb6WithResponse(c.Context, opt)
	if err != nil {
		return empty, errors.Join(errors.New("Failed to request JourneyDetail"), err)
	}

	if resp.StatusCode() != http.StatusOK {
		e := errorFromBytes(resp.Body)
		return empty, errors.Join(errors.New("Non 200 status code while requesting JourneyDetail"), e)
	}

	return *resp.JSON200, nil
}

func refify[T any](t T) *T {
	return &t
}

// JourneyPos delivers information about journeys inside of a region defined by
// a bounding box
//
// Bounding box is defined by the lower left coordinates (LlLat, Llon) and the
// upper right coordinates (UrLat, UrLon).
//
// dateAndTime should always be set to speed the requests up, see hafas docs:
//
//	> If not provided, all matching trains of
//	> the current timetable are taken into
//	> account. This will slow down the
//	> operation considerably.
//
// See hafas api docs 2.33
func (c *Client) JourneyPos(LlLat, LlLon, UrLat, UrLon float32, hafasTime Time, opt *vbbraw.Verb7Params) ([]vbbraw.JourneyType, error) {
	if opt == nil {
		opt = &vbbraw.Verb7Params{
			PositionMode: refify(vbbraw.CALCREPORT),
		}
	}

	opt.LlLat = LlLat
	opt.LlLon = LlLon
	opt.UrLat = UrLat
	opt.UrLon = UrLon

	d, t := hafasTime.ToHafasDateAndTime()
	opt.Date = &d
	opt.Time = &t

	resp, err := c.ClientWithResponses.Verb7WithResponse(c.Context, opt)
	if err != nil {
		return nil, errors.Join(errors.New("Failed to request JourneyPos"), err)
	}

	if resp.StatusCode() != http.StatusOK {
		e := errorFromBytes(resp.Body)
		return nil, errors.Join(errors.New("Non 200 status code while requesting JourneyPos"), e)
	}

	return *resp.JSON200.Journey, nil
}
